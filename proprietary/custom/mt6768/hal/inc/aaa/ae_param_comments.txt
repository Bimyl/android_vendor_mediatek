/* Copyright Statement:
 *
 * This software/firmware and related documentation ("MediaTek Software") are
 * protected under relevant copyright laws. The information contained herein
 * is confidential and proprietary to MediaTek Inc. and/or its licensors.
 * Without the prior written permission of MediaTek inc. and/or its licensors,
 * any reproduction, modification, use or disclosure of MediaTek Software,
 * and information contained herein, in whole or in part, shall be strictly prohibited.
 */
/* MediaTek Inc. (C) 2010. All rights reserved.
 *
 * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
 * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
 * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
 * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
 * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
 * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
 * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
 * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
 * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
 * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
 * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
 * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
 * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
 * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
 * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
 * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
 *
 * The following software/firmware and/or related documentation ("MediaTek Software")
 * have been modified by MediaTek Inc. All revisions are subject to any receiver's
 * applicable license agreements with MediaTek Inc.
 */


/*********************************************************************/
// Feature name : AE Paremeters Setting
// 
// Variable name: bEnablePreIndex
// A switch for enabling use of previous EV index. 
// Scenario: Leave camera app and return to camera app. There are 2 option. One is previous index the other is u4InitIndex.
// Default value: TRUE.
// Data range: N/A.
// Constraints: N/A.
// Effect : Set TRUE to enable use of previous EV index.
// 
// Variable name: bEnableRotateWeighting
// A switch for rotating weighting table.
// Default value: TRUE.
// Data range: N/A.
// Constraints: N/A.
// Effect : Set TRUE to enable rotating weighting table. Used when the weighting table is not symmetric.
// 
// Variable name: bEV0TriggerStrobe 
// A switch for taking the use of EV compensation to compute BV.
// Default value: TRUE.
// Data range: N/A.
// Constraints: N/A.
// Effect : Set TRUE to enable the use of EV compensation to compute BV.
// 
// Variable name: bEnableFaceAE
// A switch for Face AE.
// Default value: TRUE.
// Data range: N/A.
// Constraints: N/A.
// Effect : Set TRUE to enable Face AE.
// 
// Variable name: bEnableMeterAE
// A switch for Touch Metering AE.
// Default value: TRUE.
// Data range: N/A.
// Constraints: N/A.
// Effect : Set TRUE to enable Touch Metering AE.
// 
// Variable name: bEnableTouchSmoothRatio 
// A switch for Touch Smooth Converge.
// Default value: FALSE.
// Data range: N/A.
// Constraints: N/A.
// Effect : Set TRUE to enable Touch Smooth. Index changes smoothly in touch mode.
// 
// Variable name: bEnableTouchSmooth
// A switch for Touch Smooth for Perframe.
// Default value: FALSE.
// Data range: N/A.
// Constraints: N/A.
// Effect : Set TRUE to enable Touch Smooth for Perframe.
// 
// Variable name: bEnableFlareFastConverge
// A switch for Flare Fast Converge.
// Default value: TRUE.
// Data range: N/A.
// Constraints: N/A.
// Effect : Set TRUE to enable Flare Fast Converge.
// 
// Variable name: bEnableRAFastConverge
// A switch for RA Fast Converge.
// Default value: TRUE.
// Data range: N/A.
// Constraints: N/A.
// Effect : Set TRUE to enable RA Fast Converge.
// 
// Variable name: u4AEWinodwNumX 
// AE statistic winodw number in x-axis.
// Default value: 120.
// Data range: Integer, u4AEWinodwNumX > 0.
// Constraints: N/A.
// Effect : The raw data is down-sampled to another dimenstions(u4AEWinodwNumX x u4AEWinodwNumY).
// 
// Variable name: u4AEWinodwNumY 
// AE statistic winodw number in y-axis.
// Default value: 90.
// Data range: Integer, u4AEWinodwNumY > 0.
// Constraints: N/A.
// Effect : The raw data is down-sampled to another dimenstions(u4AEWinodwNumX x u4AEWinodwNumY).
// 
// Variable name: AE_BLOCK_NO 
// AE statistic block number in x-axis.
// Default value: 5.
// Data range: Integer, 0 < AE_BLOCK_NO < u4AEWinodwNumX.
// Constraints: N/A.
// Effect : The raw data(u4AEWinodwNumX x u4AEWinodwNumY) is down-sampled to another dimenstions(AE_BLOCK_NO x AE_BLOCK_NO).
// 
// Variable name: AE_BLOCK_NO 
// AE statistic block number in y-axis.
// Default value: 5.
// Data range: Integer, 0 < AE_BLOCK_NO < u4AEWinodwNumY.
// Constraints: N/A.
// Effect : The raw data(u4AEWinodwNumX x u4AEWinodwNumY) is down-sampled to another dimenstions(AE_BLOCK_NO x AE_BLOCK_NO).
// 
// Variable name: AE_TG_BLOCK_NO_X 
// AE statistic block number in x-axis.
// Default value: 12.
// Data range: Integer, 0 < AE_TG_BLOCK_NO_X < u4AEWinodwNumX.
// Constraints: N/A.
// Effect :
// 
// Variable name: AE_TG_BLOCK_NO_Y 
// AE statistic block number in y-axis.
// Default value: 9.
// Data range: Integer, 0 < AE_TG_BLOCK_NO_Y < u4AEWinodwNumY.
// Constraints: N/A.
// Effect :
// 
// Variable name: u4MinYLowBound 
// Low bound for Touch Metering Target.
// Default value: 10.
// Data range: Integer, u4MinYLowBound > 0.
// Constraints: N/A.
// Effect : It will limit the minimum value of Touch Metering Target.
// 
// Variable name: u4MaxYHighBound 
// High bound for Touch Metering Target.
// High bound for Face Detection Target when its low bound is not found.
// Default value: 256.
// Data range: Integer, u4MaxYHighBound > 0.
// Constraints: N/A.
// Effect : It will limit the maximum value of Touch Metering Target.
//          It will limit the maximum value of Face Detection Target when its high bound is not found.
// 
// Variable name: u4MeterWeight
// Weighting of Touch Metering Target.
// Default value: 1024.
// Data range: Integer, u4MeterWeight > 0.
// Constraints: N/A.
// Effect : Final Touch Metering Target will considered the central weighting value.
//          If the u4MeterWeight is lower, the percentage of luminance central weighting value contributes is higher.
// 
// Variable name: u4MinCWRecommend 
// Low bound for final AE target.
// Default value: 1.
// Data range: Integer, u4MinCWRecommend > 0.
// Constraints: N/A.
// Effect : It will limit the minimum value of final target.
// 
// Variable name: u4MaxCWRecommend 
// High bound for final AE target.
// Default value: 250.
// Data range: Integer, u4MaxCWRecommend > 0 .
// Constraints: N/A.
// Effect : It will limit the maximum value of final target.
// 
// Variable name: iMiniBVValue
// Low bound for BV.
// Default value: -50.
// Data range: Integer.
// Constraints: N/A.
// Effect : It will limit the minimum value of BV.
//  
// Variable name: u4CenterFaceExtraWeighting 
// Extra weighting for the maximal bounding box of face detection.
// Default value: 1.
// Data range: Integer.
// Constraints: N/A.
// Effect : The higher u4CenterFaceExtraWeighting is, the higher the weighting of the maximal bounding box of face detection.
// 
// Variable name: u2AEStatThrs
// Threshold for detecting change of AE Statistics.
// Default value: 7.
// Data range: Integer, u2AEStatThrs > 0.
// Constraints: N/A.
// Effect : 
// 
// Variable name: uCycleNumAESkipAfterExit
// A threshold to decide whether we need AE algo.
// Default value: 1.
// Data range: Integer, uCycleNumAESkipAfterExit >= 0.
// Constraints: N/A.
// Effect : If AE is stable for uCycleNumAESkipAfterExit frames, we don't call AE algo unless there is a tremendous change of scene.
// 
// Variable name: u4HSSmoothTHD 
// Threshold for HS temporal smooth
// Default value: 11.
// Data range: Integer, u4HSSmoothTHD > 0.
// Constraints: N/A.
// Effect : It is for temporal smooth in HS. The higher u4HSSmoothTHD is, the easier we get into HS smooth condition.
// 
// Variable name: u4FinerEvIndexBase
// Base for EV index
// Default value: 1.
// Data range: Integer, u4FinerEvIndexBase > 0.
// Constraints: N/A.
// Effect : If u4FinerEvIndexBase is 1, a index represents 0.1 EV(1:0.1EV 2:0.05EV 3:0.033EV  10:0.01).
// 
/*********************************************************************/  

typedef struct
{
    MBOOL   bEnableSaturationCheck;        //if toward high saturation scene , then reduce AE target
    MBOOL   bEnablePreIndex;                    // decide the re-initial index after come back to camera
    MBOOL   bEnableRotateWeighting;        // AE rotate the weighting automatically or not
    MBOOL   bEV0TriggerStrobe;
    MBOOL   bLockCamPreMeteringWin;
    MBOOL   bLockVideoPreMeteringWin;
    MBOOL   bLockVideoRecMeteringWin;
    MBOOL   bSkipAEinBirghtRange;            // To skip the AE in some brightness range for meter AE
    MBOOL   bPreAFLockAE;                        // Decide the do AE in the pre-AF or post-AF
    MBOOL   bStrobeFlarebyCapture;          // to Decide the strobe flare by capture image or precapture image
    MBOOL   bEnableFaceAE;                        // Enable the Face AE or not
    MBOOL   bEnableMeterAE;                      // Enable the Meter AE or not
    MBOOL   bFlarMaxStepGapLimitEnable;   //enable max step gap for low light
    MBOOL   bEnableAESmoothGain;             // Enable AE smooth gain
    MBOOL   bEnableLongCaptureCtrl;          // enable the log capture control sequence
    MBOOL   bEnableTouchSmoothRatio;         // enable Touch mode smooth converge
    MBOOL   bEnableTouchSmooth;              // enable Touch mode smooth with perframe
    MBOOL   bEnablePixelBaseHist;            // enable pixel based histogram
    MBOOL   bEnableHDRSTATconfig;            // enable HDR Y LSB config
    MBOOL   bEnableAEOVERCNTconfig;          // enable AE over-exposure count config
    MBOOL   bEnableTSFSTATconfig;            // enable TSF RGB STAT config
    MUINT8   bEnableHDRLSB;                     //HW HDR enable flag 0:8bit(default) 1:12bit 2:14bit
    MBOOL   bEnableFlareFastConverge;        // enable fast flare converge
    MBOOL   bEnableRAFastConverge;           // enable fast RA converge
    MBOOL   bEnableFaceFastConverge;         // enable fast face converge
    MUINT32 u4BackLightStrength;              // strength of backlight condtion
    MUINT32 u4OverExpStrength;               // strength of anti over exposure
    MUINT32 u4HistStretchStrength;           //strength of  histogram stretch
    MUINT32 u4SmoothLevel;                      // time LPF smooth level , internal use
    MUINT32 u4TimeLPFLevel;                     //time LOW pass filter level
    MUINT32 u4AEWinodwNumX;                   // AE statistic winodw number X
    MUINT32 u4AEWinodwNumY;                   // AE statistic winodw number Y
    MUINT8 uBlockNumX;                         //AE X block number
    MUINT8 uBlockNumY;                         //AE Yblock number
    MUINT8 uTgBlockNumX;                         //AE X block number
    MUINT8 uTgBlockNumY;                         //AE Yblock number
    MUINT8 uSatBlockCheckLow;             //saturation block check , low thres
    MUINT8 uSatBlockCheckHigh;            //sturation  block check , hight thres
    MUINT8 uSatBlockAdjustFactor;        // adjust factore , to adjust central weighting target value
    MUINT8 uMeteringYLowSkipRatio;     // metering area min Y value to skip AE
    MUINT8 uMeteringYHighSkipRatio;    // metering area max Y value to skip AE
    MUINT32 u4MinYLowBound;                 // metering boundary min Y value
    MUINT32 u4MaxYHighBound;                // metering boundary max Y value
    MUINT32 u4MeterWeight;              // metering weight betwenn CWR and MeterTarget
    MUINT32 u4MinCWRecommend;           // mini target value
    MUINT32 u4MaxCWRecommend;          // max target value
    MINT8   iMiniBVValue;                          // mini BV value.
    MINT8   uAEShutterDelayCycle;         // for AE smooth used.
    MINT8   uAESensorGainDelayCycleWShutter;
    MINT8   uAESensorGainDelayCycleWOShutter;
    MINT8   uAEIspGainDelayCycle;

    // custom Y coefficients
    MUINT32   u4AEYCoefR;        // for AE_YCOEF_R
    MUINT32   u4AEYCoefG;        // for AE_YCOEF_G
    MUINT32   u4AEYCoefB;        // for AE_YCOEF_B

    MUINT32   u4LongCaptureThres;          // enable the log capture control sequence
    MUINT32   u4CenterFaceExtraWeighting;  // give center face an extra weighting
    MUINT16 u2AEStatThrs;
    MUINT8  uCycleNumAESkipAfterExit;
    MUINT8  uOverExpoTHD;                  //overexposure cnt threshold
    MUINT32 u4HSSmoothTHD;
    MUINT32 u4FinerEvIndexBase;            // 1:0.1EV 2:0.05EV 3:0.033EV  10:0.01
}strAEParamCFG;

/*********************************************************************/
// Feature name : AE Weighting Table
// A 2D array. 
// Variable name: pWeighting
// Default value: N/A.
// Data range: N/A.
// Constraints: N/A.
// Effect : We get central weighting value by taking element-wise multiplication 
//          of central weighting and raw data. Central weighting value is always referenced 
//          when calculating the target in each AE scenario.
//          
/*********************************************************************/

typedef struct
{
   eWeightingID eID;  //weighting table ID
   MUINT32 W[5][5];    //AE weighting table
}strWeightTable;

/*********************************************************************/
// Feature name : AF PLine Table
// 
// Variable name: bAFPlineEnable
// A switch for changing fps to assist AF.
// Default value: 0.
// Data range: 0 or 1.
// Constraints: N/A.
// 
// Variable name: i2FrameRate
// A table for assisting AF.
// Default value: N/A.
// Data range: N/A.
// Constraints: N/A.
// Effect: Limit fps according to LV. 
/*********************************************************************/

typedef struct
{
   MBOOL bAFPlineEnable;
   MINT16 i2FrameRate[5][2];
}strAFPlineInfo;

/******************************************************************************/
// Feature name : EV Compensation. 
// 
// Variable name: g_strEVValueArray.
// A LUT for EV Compensation.
// Default value: N/A.
// Data range: N/A.
// Constraints: N/A. increase mono 1024 base
// Effect: Decide the how much EV will be increased or decreased.   
//         
/******************************************************************************/
static MUINT32 g_strEVValueArray[LIB3A_AE_EV_COMP_MAX] =
{
   1024,  // EV   0
   1097,   //EV    0.1
   1176,   //EV    0.2
   1261,   //EV    0.3
   1351,   //EV    0.4
   1448,   //EV    0.5
   1552,   //EV    0.6
   1663,   //EV    0.7
   1783,   //EV    0.8
   1911,   //EV    0.9
   2048,   //EV    1
   2195,   //EV    1.1
   2353,   //EV    1.2
   2521,   //EV    1.3
   2702,   //EV    1.4
   2896,   //EV    1.5
   3104,   //EV    1.6
   3327,   //EV    1.7
   3566,   //EV    1.8
   3822,   //EV    1.9
   4096,   //EV    2
   4390,   //EV    2.1
   4705,   //EV    2.2
   5043,   //EV    2.3
   5405,   //EV    2.4
   5793,   //EV    2.5
   6208,   //EV    2.6
   6654,   //EV    2.7
   7132,   //EV    2.8
   7643,   //EV    2.9
   8192,   //EV    3
   8780,   //EV    3.1
   9410,   //EV    3.2
   10086,  //EV    3.3
   10809,  //EV    3.4
   11585,  //EV    3.5
   12417,  //EV    3.6
   13308,  //EV    3.7
   14263,  //EV    3.8
   15287,  //EV    3.9
   16384,  //EV    4
   955,    //EV    -0.1
   891,    //EV    -0.2
   832,    //EV    -0.3
   776,    //EV    -0.4
   724,    //EV    -0.5
   676,    //EV    -0.6
   630,    //EV    -0.7
   588,    //EV    -0.8
   549,    //EV    -0.9
   512,    //EV    -1
   478,    //EV    -1.1
   446,    //EV    -1.2
   416,    //EV    -1.3
   388,    //EV    -1.4
   362,    //EV    -1.5
   338,    //EV    -1.6
   315,    //EV    -1.7
   294,    //EV    -1.8
   274,    //EV    -1.9
   256,    //EV    -2
   239,    //EV    -2.1
   223,    //EV    -2.2
   208,    //EV    -2.3
   194,    //EV    -2.4
   181,    //EV    -2.5
   169,    //EV    -2.6
   158,    //EV    -2.7
   147,    //EV    -2.8
   137,    //EV    -2.9
   128,    //EV    -3
   119,    //EV    -3.1
   111,    //EV    -3.2
   104,    //EV    -3.3
   97, //EV    -3.4
   91, //EV    -3.5
   84, //EV    -3.6
   79, //EV    -3.7
   74, //EV    -3.8
   69, //EV    -3.9
   64, //EV    -4
};


/******************************************************************************/
// Feature name : AE Panoroma.
//
// Variable name: iLEVEL1_GAIN.
// A threshold for the deltaIndex.
// Default value: 2.
// Data range: Integer.
// Constraints: iLEVEL1_GAIN < iLEVEL2_GAIN < iLEVEL3_GAIN < iLEVEL4_GAIN < iLEVEL5_GAIN < iLEVEL6_GAIN
// Effect: 
//
// Variable name: iLEVEL2_GAIN.
// A threshold for the deltaIndex.
// The deltaIndex > iLEVEL1_GAIN
// Default value: 10.
// Data range: Integer.
// Constraints: iLEVEL1_GAIN < iLEVEL2_GAIN < iLEVEL3_GAIN < iLEVEL4_GAIN < iLEVEL5_GAIN < iLEVEL6_GAIN
// Effect: 
//
// Variable name: iLEVEL3_GAIN.
// A threshold for the deltaIndex.
// The deltaIndex > iLEVEL2_GAIN
// Default value: 18.
// Data range: Integer.
// Constraints: iLEVEL1_GAIN < iLEVEL2_GAIN < iLEVEL3_GAIN < iLEVEL4_GAIN < iLEVEL5_GAIN < iLEVEL6_GAIN
// Effect: 
//
// Variable name: iLEVEL4_GAIN.
// A threshold for the deltaIndex.
// The deltaIndex > iLEVEL3_GAIN
// Default value: 28.
// Data range: Integer.
// Constraints: iLEVEL1_GAIN < iLEVEL2_GAIN < iLEVEL3_GAIN < iLEVEL4_GAIN < iLEVEL5_GAIN < iLEVEL6_GAIN
// Effect: 
//
// Variable name: iLEVEL5_GAIN.
// A threshold for the deltaIndex.
// The deltaIndex > iLEVEL4_GAIN
// Default value: 40.
// Data range: Integer.
// Constraints: iLEVEL1_GAIN < iLEVEL2_GAIN < iLEVEL3_GAIN < iLEVEL4_GAIN < iLEVEL5_GAIN < iLEVEL6_GAIN
// Effect: 
//
// Variable name: iLEVEL6_GAIN.
// A threshold for the deltaIndex.
// The deltaIndex > iLEVEL5_GAIN
// Default value: 50.
// Data range: Integer.
// Constraints: iLEVEL1_GAIN < iLEVEL2_GAIN < iLEVEL3_GAIN < iLEVEL4_GAIN < iLEVEL5_GAIN < iLEVEL6_GAIN
// Effect: 
//
// Variable name: iLEVEL1_TARGET_DIFFERENCE.
// Weighting to control high bound of deltaIndex.
// Default value: 0.
// Data range: Integer.
// Constraints: N/A.
// Effect: The higher iLEVEL1_TARGET_DIFFERENCE is, the higher the high bound of deltaIndex is.
//         The higher iLEVEL1_TARGET_DIFFERENCE is, the lower the low bound of deltaIndex is.
//
// Variable name: iLEVEL2_TARGET_DIFFERENCE.
// Weighting to control high bound of deltaIndex.
// Default value: 4.
// Data range: Integer.
// Constraints: N/A.
// Effect: The higher iLEVEL2_TARGET_DIFFERENCE is, the higher the high bound of deltaIndex is.
//         The higher iLEVEL2_TARGET_DIFFERENCE is, the lower the low bound of deltaIndex is.
//
// Variable name: iLEVEL3_TARGET_DIFFERENCE.
// Weighting to control high bound of deltaIndex.
// Default value: 7.
// Data range: Integer.
// Constraints: N/A.
// Effect: The higher iLEVEL3_TARGET_DIFFERENCE is, the higher the high bound of deltaIndex is.
//         The higher iLEVEL3_TARGET_DIFFERENCE is, the lower the low bound of deltaIndex is.
//
// Variable name: iLEVEL4_TARGET_DIFFERENCE.
// Weighting to control high bound of deltaIndex.
// Default value: 7.
// Data range: Integer.
// Constraints: N/A.
// Effect: The higher iLEVEL4_TARGET_DIFFERENCE is, the higher the high bound of deltaIndex is.
//         The higher iLEVEL4_TARGET_DIFFERENCE is, the lower the low bound of deltaIndex is.
//
// Variable name: iLEVEL5_TARGET_DIFFERENCE.
// Weighting to control high bound of deltaIndex.
// Default value: 7.
// Data range: Integer.
// Constraints: N/A.
// Effect: The higher iLEVEL5_TARGET_DIFFERENCE is, the higher the high bound of deltaIndex is.
//         The higher iLEVEL5_TARGET_DIFFERENCE is, the lower the low bound of deltaIndex is.
//
// Variable name: iLEVEL6_TARGET_DIFFERENCE.
// Weighting to control high bound of deltaIndex.
// Default value: 7.
// Data range: Integer.
// Constraints: N/A.
// Effect: The higher iLEVEL6_TARGET_DIFFERENCE is, the higher the high bound of deltaIndex is.
//         The higher iLEVEL6_TARGET_DIFFERENCE is, the lower the low bound of deltaIndex is.
//
// Variable name: iLEVEL1_GAINH.
// Weighting to control high bound of deltaIndex after clipping.
// Default value: 2.
// Data range: Integer.
// Constraints: N/A.
// Effect: The higher iLEVEL1_GAINH is, the higher the high bound of deltaIndex after clipping is.
//
// Variable name: iLEVEL2_GAINH.
// Weighting to control high bound of deltaIndex after clipping.
// Default value: 6.
// Data range: Integer.
// Constraints: N/A.
// Effect: The higher iLEVEL2_GAINH is, the higher the high bound of deltaIndex after clipping is.
//
// Variable name: iLEVEL3_GAINH.
// Weighting to control high bound of deltaIndex after clipping.
// Default value: 8.
// Data range: Integer.
// Constraints: N/A.
// Effect: The higher iLEVEL3_GAINH is, the higher the high bound of deltaIndex after clipping is.
//
// Variable name: iLEVEL4_GAINH.
// Weighting to control high bound of deltaIndex after clipping.
// Default value: 10.
// Data range: Integer.
// Constraints: N/A.
// Effect: The higher iLEVEL4_GAINH is, the higher the high bound of deltaIndex after clipping is.
//
// Variable name: iLEVEL5_GAINH.
// Weighting to control high bound of deltaIndex after clipping.
// Default value: 12.
// Data range: Integer.
// Constraints: N/A.
// Effect: The higher iLEVEL5_GAINH is, the higher the high bound of deltaIndex after clipping is.
//
// Variable name: iLEVEL6_GAINH.
// Weighting to control high bound of deltaIndex.
// Default value: 15.
// Data range: Integer.
// Constraints: N/A.
// Effect: The higher the high bound of deltaIndex after clipping is.
//
// Variable name: iLEVEL1_GAINL.
// Weighting to control low bound of deltaIndex.
// Default value: -2.
// Data range: Integer.
// Constraints: N/A.
// Effect: The higher iLEVEL1_GAINL is, the higher the low bound of deltaIndex after clipping is.
//
// Variable name: iLEVEL2_GAINL.
// Weighting to control low bound of deltaIndex.
// Default value: -7.
// Data range: Integer.
// Constraints: N/A.
// Effect: The higher iLEVEL2_GAINL is, the higher the low bound of deltaIndex after clipping is.
//
// Variable name: iLEVEL3_GAINL.
// Weighting to control low bound of deltaIndex.
// Default value: -9.
// Data range: Integer.
// Constraints: N/A.
// Effect: The higher iLEVEL3_GAINL is, the higher the low bound of deltaIndex after clipping is.
//
// Variable name: iLEVEL4_GAINL.
// Weighting to control low bound of deltaIndex.
// Default value: -12.
// Data range: Integer.
// Constraints: N/A.
// Effect: The higher iLEVEL4_GAINL is, the higher the low bound of deltaIndex after clipping is.
//
// Variable name: iLEVEL5_GAINL.
// Weighting to control low bound of deltaIndex.
// Default value: -16.
// Data range: Integer.
// Constraints: N/A.
// Effect: The higher iLEVEL5_GAINL is, the higher the low bound of deltaIndex after clipping is.
//
// Variable name: iLEVEL6_GAINL.
// Weighting to control low bound of deltaIndex.
// Default value: -20.
// Data range: Integer.
// Constraints: N/A.
// Effect: The higher iLEVEL6_GAINL is, the higher the low bound of deltaIndex after clipping is.
//
// Variable name: iGAIN_DIFFERENCE_LIMITER.
// Weighting to control high bound for the difference of clipped deltaIndex and original deltaIndex.
// Default value: 1.
// Data range: Integer.
// Constraints: N/A.
// Effect: The high iGAIN_DIFFERENCE_LIMITER is, the higher the high bound for the difference of clipped deltaIndex and original deltaIndex is.
//
/******************************************************************************/

typedef struct
{
    MINT8 iLEVEL1_GAIN;
    MINT8 iLEVEL2_GAIN;
    MINT8 iLEVEL3_GAIN;
    MINT8 iLEVEL4_GAIN;
    MINT8 iLEVEL5_GAIN;
    MINT8 iLEVEL6_GAIN;
    MINT8 iLEVEL1_TARGET_DIFFERENCE;
    MINT8 iLEVEL2_TARGET_DIFFERENCE;
    MINT8 iLEVEL3_TARGET_DIFFERENCE;
    MINT8 iLEVEL4_TARGET_DIFFERENCE;
    MINT8 iLEVEL5_TARGET_DIFFERENCE;
    MINT8 iLEVEL6_TARGET_DIFFERENCE;
    MINT8 iLEVEL1_GAINH;
    MINT8 iLEVEL1_GAINL;
    MINT8 iLEVEL2_GAINH;
    MINT8 iLEVEL2_GAINL;
    MINT8 iLEVEL3_GAINH;
    MINT8 iLEVEL3_GAINL;
    MINT8 iLEVEL4_GAINH;
    MINT8 iLEVEL4_GAINL;
    MINT8 iLEVEL5_GAINH;
    MINT8 iLEVEL5_GAINL;
    MINT8 iLEVEL6_GAINH;
    MINT8 iLEVEL6_GAINL;
    MINT8 iGAIN_DIFFERENCE_LIMITER;
}strAELimiterTable;


/******************************************************************************/
// Feature name : AE Face Location and Size Check.
//
// Variable name: bFaceLocSizeCheck. 
// A switch for AE Face Location and Size Check.
// Default value: FALSE.
// Data range: TRUE or FALSE.
// Constraints: N/A.
// Effect: Set TRUE to enable AE Face Location Size Check.
//
// Variable name: u4Size_X.
// Range of the size of the bounding box for face detection.
// We will calculate the probability according to size of the bounding box. 
// Default value: {35, 10}.
// Data range: Integer, u4Size_X[0] > 0, u4Size_X[1] >= 0.
// Constraints: u4Size_X[0] > u4Size_X[1].
// Effect: The smaller entries in u4Size_X are, the larger probability we get. 
//
// Variable name: u4Size_Y.
// Range of probability. 
// Default value: {1024, 256}.
// Data range: Integer, 0 <= u4Size_Y[0] <= 1024 , 0 <= u4Size_Y[1] <= 1024 .
// Constraints: u4Size_Y[0] > u4Size_Y[1].
// Effect: The larger entries in u4Size_Y are, the larger probability we get.
//
// Variable name: u4Loc_X.
// Range of distance between the bounding box of face detection and center of the scene.
// We will find the probability according to distance between the bounding box of face detection and center of the scene.
// Default value: {200, 600}.
// Data range: Integer, u4Loc_X[0] >= 0, u4Loc_X[1] >= 0.
// Constraints: u4Loc_X[0] < u4Loc_X[1].
// Effect: The smaller entries in u4Loc_X are, the smaller probability we get.
//
// Variable name: u4Loc_Y.
// Range of probability. 
// We will find the probability according to distance between center of the bounding box of face detection and center of the scene.
// Default value: {1024, 256}.
// Data range: Integer, 0 <= u4Loc_Y[0] <= 1024 , 0 <= u4Loc_Y[1] <= 1024.
// Constraints: u4Loc_Y[0] > u4Loc_Y[1].
// Effect: The larger entries in u4Loc_Y are, the larger probability we get.
//
// 
/******************************************************************************/

typedef struct {
    MBOOL   bFaceLocSizeCheck;
    MUINT32 u4Size_X[2];
    MUINT32 u4Size_Y[2];
    MUINT32 u4Loc_X[2];
    MUINT32 u4Loc_Y[2];
} strFaceLocSize;

/******************************************************************************/
// Feature name : AE Perframe.
//
// Variable name: i4DeltaEVDiff.
// A threshold to determine whether the predicted new target is available.
// Default value: 200.
// Data range: Integer, i4DeltaEVDiff >= 0.
// Constraints: N/A.
// Effect: The higher i4DeltaEVDiff is, the easier predict target takes effect.
//
// Variable name: u4PredY_H. 
// High bound for central weighting value in B2T direction for perframe.
// Default value: 240.
// Data range: Integer, u4PredY_H >= 0.
// Constraints: N/A.
// Effect: Avoid damping.
//
// Variable name: u4PredY_L.
// Low bound for central weighting value in D2T direction for perframe.
// Default value: 4.
// Data range: Integer, u4PredY_H >= 0.
// Constraints: N/A.
// Effect: Avoid damping.
//
// Variable name: u4AccY_Max.
// High bound for central weighting value.
// Threshold for judging the extreme condition.
// Default value: 254.
// Data range: Integer, u4AccY_Max >= 0.
// Constraints: N/A.
// Effect: The higher u4AccY_Max is, the easier perframe mechanism takes effect.
//
// Variable name: bRecycleEnable.
// A switch for recycle mechanism.
// Default value: TRUE.
// Data range: TRUE or FALSE.
// Constraints: N/A.
// Effect: Set TRUE to enable recycle mechanism.
//
// Variable name: u4AccY_Min.
// Threshold for judging the extreme condition.
// Default value: 1.
// Data range: Integer, u4AccY_Min >= 0.
// Constraints: N/A.
// Effect: If the u4AccY_Min is higher, we will be easier to believe it is an extreme condition.
// 
/******************************************************************************/

typedef struct {
    MINT32  i4DeltaEVDiff;
    MUINT32 u4WoAccRatio;// 65
    MUINT32 u4BoAccRatio;// 80
    MUINT32 u4PredY_H;// 240
    MUINT32 u4PredY_L;// 4
    MUINT32 u4AccY_Max;//254
    MUINT32 u4AccCWV_Max;// 510
    MUINT32 u4AccY_Min;// 1
    MBOOL   bRecycleEnable;
} strPerframeCFG;

/******************************************************************************/
// Feature name : TG Initialization Parameters.
//
// Variable name: OverExpoThr.
// A threshold to decide whether TG speedup takes effect.
// Default value: 245.
// Data range: Integer, OverExpoThr >= 0.
// Constraints: N/A.
// Effect: If central weighting value is larger than OverExpoThr, TG speedup takes effect.
//
// Variable name: OverExpoRatio.
// A threshold to decide whether TG speedup takes effect.
// Default value: 70.
// Data range: Integer, 0 <= OverExpoRatio <= 100.
// Constraints: N/A.
// Effect: If the over-exposure ratio of whole image is larger than OverExpoRatio, TG speedup takes effect.
//
// Variable name: OverExpoResetAccEVTh.
// A threshold to decide whether the accumulated EV should be reset(In normal case).
// Default value: 200.
// Data range: Integer, OverExpoResetAccEVTh >= 0.
// Constraints: N/A.
// Effect: If central weighting value is smaller than OverExpoResetAccEVTh, the accumulated EV will be reset.
//
// Variable name: OverExpoSTD_Th.
// Threshold for STD to decide the OverExpoSTD_Ratio.
// Default value: {80, 300, 500}.
// Data range: Integer, OverExpoSTD_Th[0] >= 0, OverExpoSTD_Th[1] >= 0, OverExpoSTD_Th[2] >= 0.
// Constraints: Monotonically increasing.
// Effect: If STD of over-exposure is in a specific range, we pick up a corresponding ratio for delta index.
//
// Variable name: OverExpoSTD_Ratio.
// Ratio to decrease AE converge step.
// Default value: {100, 85, 60, 40}.
// Data range: Integer, OverExpoSTD_Ratio[0] >= 0, OverExpoSTD_Ratio[1] >= 0, OverExpoSTD_Ratio[2] >= 0, OverExpoSTD_Ratio[3] >= 0.
// Constraints: Decreasing.
// Effect: The delta index we get will multiplied by this ratio. Enlarge the value to accelerate AE converge speed. 
//
// Variable name: OverExpoAccDeltaEV_Th.
// A threshold to decide the OverExpoAccDeltaEV_DeltaEV.
// Default value: {30, 40, 50}.
// Data range: Integer, OverExpoAccDeltaEV_Th[0] >= 0, OverExpoAccDeltaEV_Th[1] >= 0, OverExpoAccDeltaEV_Th[2] >= 0.
// Constraints: Monotonically increasing.
// Effect: If the accumulated  delta EV is in a specific range, we pick up a corresponding delta EV.
//
// Variable name: OverExpoAccDeltaEV_DeltaEV.
// A value decided by OverExpoAccDeltaEV_Th.
// EX. Accumulated Delta EV < 30, we pick -30 as delta EV.
//     30 <= Accumulated Delta EV < 40, we pick -24 as delta EV.
// Default value: {-30, -24, -20, -20}.
// Data range: Integer, OverExpoAccDeltaEV_DeltaEV[0] <= 0, OverExpoAccDeltaEV_DeltaEV[1] <= 0, OverExpoAccDeltaEV_DeltaEV[2] <= 0, OverExpoAccDeltaEV_DeltaEV[3] <= 0.
// Constraints: Increasing.
// Effect: The parameter decide how large step AE will move. If the value is smaller (ex. Change from -30 to -35), the faster converge speed will be.
//
// Variable name: OverExpoCountSTD_Th.
// A threshold to decide if we need to take the value of raw data into account for STD computation.
// Default value: 200.
// Data range: Integer, OverExpoCountSTD_Th >= 0.
// Constraints: N/A.
// Effect: If the value is between OverExpoCountSTD_Th and 255, we take this value into account for STD computation.
//
// Variable name: UnderExpoThr.
// A threshold to decide whether TG speedup takes effect.
// Default value: 7.
// Data range: Integer, UnderExpoThr >= 0.
// Constraints: N/A.
// Effect: If central weighting value is less than OverExpoThr, TG speedup takes effect.
//
// Variable name: UnderExpoRatio.
// A threshold to decide whether TG speedup takes effect.
// Default value: 95.
// Data range: Integer, UnderExpoRatio >= 0.
// Constraints: N/A.
// Effect: If the under-exposure ratio of whole image is larger than UnderExpoRatio, TG speedup takes effect.
//
// Variable name: UnderExpoResetAccEVTh.
// A threshold to decide whether the accumulated EV should be reset(In normal case).
// Default value: 20.
// Data range: Integer, UnderExpoResetAccEVTh >= 0.
// Constraints: N/A.
// Effect: If central weighting value is larger than UnderExpoResetAccEVTh, the accumulated EV will be reset.
//
// Variable name: UnderExpoSTD_Th.
// Threshold for STD to decide the UnderExpoSTD_Ratio.
// Default value: {80, 250, 500}.
// Data range: Integer, UnderExpoSTD_Th[0] >= 0, UnderExpoSTD_Th[1] >= 0, UnderExpoSTD_Th[2] >= 0.
// Constraints: Monotonically increasing.
// Effect: If STD of under-exposure is in a specific range, we pick up a corresponding ratio for delta index.
//
// Variable name: UnderExpoSTD_Ratio.
// Ratio to decrease AE converge step.
// Default value: {100, 85, 60, 35}.
// Data range: Integer, UnderExpoSTD_Ratio[0] >= 0, UnderExpoSTD_Ratio[1] >= 0, UnderExpoSTD_Ratio[2] >= 0, UnderExpoSTD_Ratio[3] >= 0.
// Constraints: Decreasing.
// Effect: The delta index we get will multiplied by this ratio. Enlarge the value to accelerate AE converge speed.
//
// Variable name: UnderExpoAccDeltaEV_Th.
// A threshold to decide the UnderExpoAccDeltaEV_DeltaEV.
// Default value: {30, 40, 50}.
// Data range: Integer, UnderExpoAccDeltaEV_Th[0] >= 0, UnderExpoAccDeltaEV_Th[1] >= 0, UnderExpoAccDeltaEV_Th[2] >= 0.
// Constraints: Monotonically increasing.
// Effect: If the accumulated  delta EV is in a specific range, we pick up a corresponding delta EV.
//
// Variable name: UnderExpoAccDeltaEV_DeltaEV.
// A value decided by UnderExpoAccDeltaEV_Th.
// EX. Accumulated Delta EV < 30, we pick 20 as delta EV.
//     30 <= Accumulated Delta EV < 40, we pick 15 as delta EV.
// Default value: {20, 15, 10, 10}.
// Data range: Integer, UnderExpoAccDeltaEV_DeltaEV[0] >= 0, UnderExpoAccDeltaEV_DeltaEV[1] >= 0, UnderExpoAccDeltaEV_DeltaEV[2] >= 0, UnderExpoAccDeltaEV_DeltaEV[3] >= 0.
// Constraints: Decreasing.
// Effect: The parameter decide how large step AE will move. If the value is larger (ex. Change from 20 to 25), the faster converge speed will be.
//                                                          
//
// Variable name: UnderExpoCountSTD_Th.
// A threshold to decide if we need to take the value of raw data into account for STD computation.
// Default value: 30.
// Data range: Integer, UnderExpoCountSTD_Th >= 0.
// Constraints: N/A.
// Effect: If the value is between 0 and UnderExpoCountSTD_Th, we take this value into account for STD computation.
//
/******************************************************************************/

typedef struct
{

//B2T
    MUINT32 OverExpoThr; //245
    MUINT32 OverExpoRatio; //70%
    MUINT32 OverExpoResetAccEVTh; //200

    MUINT32 OverExpoSTD_Th[3];
    MUINT32 OverExpoSTD_Ratio[4];

    MUINT32 OverExpoAccDeltaEV_Th[3];
    MINT32 OverExpoAccDeltaEV_DeltaEV[4];

    MUINT32 OverExpoCountSTD_Th;

    MUINT32 OverExpoLowBound;
    MUINT32 OverExpLightAcc1;
    MUINT32 OverExpLightAcc2;
    MUINT32 OverExpLightAcc3;
    MUINT32 OverExpLightAcc4;

//D2T
    MUINT32 UnderExpoThr; //10
    MUINT32 UnderExpoRatio; //95%
    MUINT32 UnderExpoResetAccEVTh; //20

    MUINT32 UnderExpoSTD_Th[3];
    MUINT32 UnderExpoSTD_Ratio[4];

    MUINT32 UnderExpoAccDeltaEV_Th[3];
    MINT32 UnderExpoAccDeltaEV_DeltaEV[4];

    MUINT32 UnderExpoCountSTD_Th;

} strAETgTuningPara;

/******************************************************************************/
// Feature name : AE BV Acceleration.
// Delta BV is referenced to control the speed of convergence in wash-out scene.
// Variable name: u4BVAccEnable.
// A switch for AE BV Acceleration.
// Default value: TRUE.
// Data range: TRUE or FALSE.
// Constraints: N/A.
// Effect: Set TRUE to turn on AE BV Acceleration.
//
// Variable name: i4DeltaBVRatio.
// A weight for real delta BV. (m_i4AEFinerEVBase base)
// Default value: 90.
// Data range: Integer, i4DeltaBVRatio >= 0.
// Constraints: N/A.
// Effect: The higher i4DeltaBVRatio is, the higher the delta BV is.
//
// Variable name: u4B2T_Target.
// A start x coordinate in B2T case.
// Default value: 220.
// Data range: Integer, u4B2T_Target >= 0.
// Constraints: u4B2T_Target < u4Bright2TargetEnd.
//
// Variable name: u4SpeedUpRatio.
// A speedup ratio for AE BV acceleration.
// Default value: 100.
// Data range: Integer, u4SpeedUpRatio >= 0.
// Constraints: N/A.
// Effect: The higher u4SpeedUpRatio is, the larger step we move.
// 
// Variable name: u4Bright2TargetEnd.
// A end x coordinate in B2T case.
// The start of x coordinate in B2T case depends on CWR.
// Default value: 255
// Data range: Integer, u4Bright2TargetEnd >= 0.
// Constraints: u4B2T_Target < u4Bright2TargetEnd.
//  
// Variable name: u4Dark2TargetStart.
// A start x coordinate in D2T case.
// The end x coordinate in D2T case depends on CWR.
// Default value: 20
// Data range: Integer, u4Dark2TargetStart >= 0.
// Constraints: N/A.
// 
// Variable name: u4B2TEnd.
// A end y coordinate in B2T case.
// Default value: 200
// Data range: Integer, u4B2TEnd >= 0.
// Constraints: u4B2TEnd > u4B2TStart.
//
// Variable name: u4B2TStart.
// A start y coordinate in B2T case.
// Default value: 100
// Data range: Integer, u4B2TStart >= 0.
// Constraints: u4B2TEnd > u4B2TStart.
// 
// Variable name: u4D2TEnd.
// A end y coordinate in D2T case.
// Default value: 40
// Data range: Integer, u4D2TEnd >= 0.
// Constraints: u4D2TStart >= u4D2TEnd.
//
// Variable name: u4D2TStart.
// A start y coordinate in D2T case.
// Default value: 90
// Data range: Integer, u4D2TStart >= 0.
// Constraints: u4D2TStart >= u4D2TEnd.
// 
/******************************************************************************/ 

typedef struct {
    MBOOL u4BVAccEnable;
    MINT32 i4DeltaBVRatio;
    MUINT32 u4B2T_Target;
    strAEMovingRatio  pAEBVAccRatio;           // Preview ACC ratio
} strBVAccRatio;

typedef struct
{
        MUINT32 u4SpeedUpRatio;
        MUINT32 u4GlobalRatio;
        MUINT32 u4Bright2TargetEnd;
        MUINT32 u4Dark2TargetStart;
        MUINT32 u4B2TEnd;
        MUINT32 u4B2TStart;
        MUINT32 u4D2TEnd;
        MUINT32 u4D2TStart;
} strAEMovingRatio;

/******************************************************************************/
// Feature name : PSO Converge.
// Converge according to pure statistical output.
// Variable name: u4PsoAccEnable.
// A switch for PSO Converge.
// Default value: True.
// Data range: TRUE or FALSE.
// Constraints: N/A.
// Effect: Set TRUE to turn on HS PSO Converge.
//
// Variable name: i4PsoEscRatioWO.
// A ratio discount for Wash-Out case.
// Default value: 100.
// Data range: Integer, i4PsoEscRatioWO >= 0.
// Constraints: N/A.
// Effect: The larger i4PsoEscRatioWO is, the larger delta index we will get in Wash-Out Case.
//
// Variable name: i4PsoEscRatioNonLinear.
// A ratio discount for Non-Linear Case case.
// Default value: 50.
// Data range: Integer, i4PsoEscRatioNonLinear >= 0.
// Constraints: N/A.
// Effect: The larger i4PsoEscRatioNonLinear is, the larger delta index we will get in Non-Linear Case.
//
// Variable name: ConvergeDeltaPosBound.
// PSO converge limit upper bound.
// Default value: 4000.
// Data range: Integer, ConvergeDeltaPosBound >= 0.
// Constraints: N/A.
// Effect: PSO delta limit cannot be larger than ConvergeDeltaPosBound.
//
// Variable name: ConvergeDeltaNegBound.
// PSO converge limit lower bound.
// Default value: -4000.
// Data range: Integer, ConvergeDeltaNegBound <= 0.
// Constraints: N/A.
// Effect:  PSO delta limit cannot be smaller than ConvergeDeltaNegBound.
/******************************************************************************/

typedef struct {
    MBOOL u4PsoAccEnable;
    MINT32 i4PsoEscRatioWO;  //PSO speedup ratio discount, 100 base (Wash-Out case)
    MINT32 i4PsoEscRatioNonLinear; //PSO speedup ratio discount, 100 base (Non-Linear Case)
    MINT32 ConvergeDeltaPosBound;
    MINT32 ConvergeDeltaNegBound;
}strPSOConverge;

/******************************************************************************/
// Feature name : HS Converge Acceleration.
// When the scene is too bright, the HS Converge Accelerate mechanism will take effect to
// speedup the convergence.
// Variable name: bNonCWRAccEnable.
// A switch for HS Converge Acceleration.
// Default value: False.
// Data range: TRUE or FALSE.
// Constraints: N/A.
// Effect: Set TRUE to turn on HS Converge Acceleration.
//
// Variable name: u4HS_FHY_HBound.
// High flat Y for HS is the average of value in bright segment.
// u4HS_FHY_HBound is a threshold for high flat Y.
// Default value: 255.
// Data range: Integer, u4HS_FHY_HBound >= 0.
// Constraints: N/A.
// Effect: The lower u4HS_FHY_HBound is, the easier HS Converge Acceleration takes effect.
//   
// Variable name: u4CWV_HBound.
// u4CWV_HBound is a threshold for central weighting value.
// Default value: 160.
// Data range: Integer, u4CWV_HBound >= 0.
// Constraints: N/A.
// Effect: The lower u4CWV_HBound is, the easier HS Converge Acceleration takes effect.  
//         
// Variable name: u4HS_TargetHBound.
// u4HS_TargetHBound is a threshold for HS target.
// Default value: 160.
// Data range: Integer, u4HS_TargetHBound >= 0.
// Constraints: N/A.
// Effect: The higher u4HS_TargetHBound is, the easier HS Converge Acceleration takes effect.  
//         
// Variable name: u4HS_ACCTarget.
// u4HS_ACCTarget is a threshold for HS target ant it is also a target for HS Converge Acceleration.
// Default value: 58.
// Data range: Integer.
// Constraints: N/A.
// Effect: When condition of HS Converge Acceleration occurs, u4HS_ACCTarget takes the place of the original HS Target.
/******************************************************************************/

typedef struct {
    MBOOL   bNonCWRAccEnable;
    MUINT32 u4HS_FHY_HBound;
    MUINT32 u4CWV_HBound;
    MUINT32 u4HS_TargetHBound;
    MUINT32 u4HS_ACCTarget;
} strNonCWRAcc;

/******************************************************************************/
// Feature name : Face AE.
// Tuning parameters for Face AE
// Variable name: u4MinFDYLowBound.
// A low bound for Face Target.
// Default value: 10.
// Data range: Integer, u4MinFDYLowBound >= 0.
// Constraints: N/A.
// Effect: The Face Target should be above u4MinFDYLowBound or it may be set to u4MinFDYLowBound.
//         
// Variable name: u4MaxYHighBound.
// A high bound for Touch Metering Target.
// Default value: 256.
// Data range: Integer, u4MaxYHighBound >= 0.
// Constraints: N/A.
// Effect: The Touch Metering Target should be below u4MaxYHighBound or it may be 
//         set to u4MinFDYLowBound.
//     
// Variable name: i4FaceBVLowBound.
// Real BV is used to compute Face Target or Touch Metering Target by interpolation and 
// i4FaceBVLowBound is the low bound of BV.
// Default value: 0.
// Data range: Integer, i4FaceBVLowBound >= 0.
// Constraints: i4FaceBVLowBound < i4FaceBVHighBound.
// Effect: Given a real BV, if real BV is between i4FaceBVLowBound and i4FaceBVHighBound, we can find the target
//         between low bound and high bound by linear interpolation.
//     
// Variable name: i4FaceBVHighBound.
// Real BV is used to compute Face Target or Touch Metering Target by interpolation and 
// i4FaceBVHighBound is the high bound of BV.
// Default value: 4000.
// Data range: Integer, i4FaceBVHighBound >= 0.
// Constraints: i4FaceBVLowBound < i4FaceBVHighBound.
// Effect: Given a real BV, if real BV is between i4FaceBVLowBound and i4FaceBVHighBound, we can find the target
//         between low bound and high bound by linear interpolation.
//         
// Variable name: u4TmpFDY_HBound.
// A high bound for calculating FDY.
// Default value: 235.
// Data range: Integer, u4TmpFDY_HBound >= 0.
// Constraints: u4TmpFDY_LBound < u4TmpFDY_HBound.
// Effect: If the brightness of one face is over u4TmpFDY_HBound, we remove it.
//  
// Variable name: u4TmpFDY_LBound.
// A low bound for calculating  FDY.
// Default value: 1.
// Data range: Integer, u4TmpFDY_LBound >= 0.
// Constraints: u4TmpFDY_LBound < u4TmpFDY_HBound.
// Effect: If the brightness of one face is below u4TmpFDY_LBound, we remove it.
//  
// Variable name: u4FD_Lost_MaxCnt. 
// A threshold to justify whether there are faces or not.
// Default value: 5.
// Data range: Integer, u4FD_Lost_MaxCnt >= 0.
// Effect: If there are not faces for u4FD_Lost_MaxCnt frames, we think there is no face in the scene.
//  
// Variable name: u4FD_Scale_Ratio.
// A ratio to control the size of the bounding boxes of face detection. 100 base.
// Default value: 90.
// Data range: Integer, 0 <= u4FD_Scale_Ratio <= 100.
// Effect: The width or the height will be multiplied by u4FD_Scale_Ratio to get the size of bounding box we want.
//  
// Variable name: u4FaceNSLowBound.
// A low bound for Face Target in NS. 
// Default value: 30.
// Data range: Integer, u4FaceNSLowBound >= 0.
// Effect: The lower u4FaceNSLowBound is, the lower Face Target or Touch Metering Target is.
//  
/******************************************************************************/

typedef struct {
    MUINT32 u4MinFDYLowBound;               // face boundary min Y value
    MUINT32 u4MaxFDYHighBound;              // face boundary max Y value
    MINT32  i4FaceBVLowBound;               // face boundary min BV value
    MINT32  i4FaceBVHighBound;              // face boundary max BV value
    MUINT32 u4TmpFDY_HBound;                // tempFDY HighBound
    MUINT32 u4TmpFDY_LBound;                // tempFDY LowBound
    MUINT32 u4FD_Lost_MaxCnt;               // face lost max count
    MUINT32 u4FD_Scale_Ratio;               // face window scale ratio
    MUINT32 u4FaceNSLowBound;       //NS face target Y
    MUINT32 u4FD_Lock_MaxCnt;
    MUINT32 u4FD_MixCWR_MaxCnt;
    MUINT32 u4FD_TemporalSmooth;
    MUINT32 u4FD_FaceWidthCropRat;
    MUINT32 u4FD_FaceHeightCropRat;
    MUINT32 u4FD_InToOutThdMaxCnt;
    MUINT32 u4FD_OTLockUpperBnd;
    MUINT32 u4FD_OTLockLowerBnd;
    MUINT32 u4FD_ContinueTrustCnt;
    MUINT32 u4FD_PerframeAntiOverFlag;
    MUINT32 u4FD_SideFaceLock;
    MUINT32 u4FD_LimitStableThdLowBnd;
    MUINT32 u4FD_LimitStableThdLowBndNum;
    MUINT32 u4FD_ReConvergeWhenFaceChange;
    MUINT32 u4FD_FaceMotionLockRat;
    MUINT32 u4FD_ImpulseLockCnt;
    MUINT32 u4FD_ImpulseUpperThd;
    MUINT32 u4FD_ImpulseLowerThd;
    MUINT32 u4FD_ROPTrustCnt;
}strFaceSmooth;

/******************************************************************************/
// Feature name : AE Central Weighting Recommend Temporal Smooth
// 
// Variable name: bEnableAEHsTS
// Enable temporal smooth in HS.
// default value: FALSE.
// data range: TRUE or FALSE
// constraints: N/A
// effect: TRUE to enable temporal smooth in HS.
//         HS target will change slowly when bEnableAEHsTS is TRUE.
//         
// Variable name: bEnableAEAblTS
// Enable temporal smooth in ABL.
// default value: FALSE.
// data range: TRUE or FALSE
// constraints: N/A
// effect: TRUE to enable temporal smooth in ABL.
//         ABL target will change slowly when bEnableAEAblTS is TRUE.
//         
// Variable name: bEnableAEAoeTS
// Enable temporal smooth in AOE.
// default value: FALSE.
// data range: TRUE or FALSE
// constraints: N/A
// effect: TRUE to enable temporal smooth in AOE.
//         AOE target will change slowly when bEnableAEAoeTS is TRUE.
// 
// Variable name: bEnableAENsTS
// Enable temporal smooth in NS.
// default value: FALSE.
// data range: TRUE or FALSE
// constraints: N/A
// effect: TRUE to enable temporal smooth in NS.
//         NS target will change slowly when bEnableAENsTS is TRUE.
// 
// Variable name: bEnableAEFaceTS
// Enable temporal smooth in face AE.
// default value: TRUE.
// data range: TRUE or FALSE
// constraints: N/A
// effect: TRUE to enable temporal smooth in face AE.
//         Face AE target will change slowly when bEnableAEFaceTS is TRUE.
//         
// Variable name: bEnableAEVideoTS
// Enable temporal smooth in video mode.
// default value: TRUE.
// data range: TRUE or FALSE
// constraints: N/A
// effect: TRUE to enable temporal smooth in video mode.
//         Central weighting value will change slowly when bEnableAEVideoTS is TRUE.
//         
// Variable name: bEnableAEMainTargetTS
// Enable temporal smooth in HS.
// default value: FALSE.
// data range: TRUE or FALSE
// constraints: N/A
// effect: TRUE to enable temporal smooth in HS.
//         HS target will change slowly when bEnableAEMainTargetTS is TRUE.
// 
// Variable name: bEnableAEHsV4p0TargetTS
// Enable temporal smooth in HS.
// default value: FALSE.
// data range: TRUE or FALSE
// constraints: N/A
// effect: TRUE to enable temporal smooth in HS.
//         HS target will change slowly when bEnableAEHsV4p0TargetTS is TRUE.
/******************************************************************************/

typedef struct {
    MBOOL   bEnableAEHsTS;                   // enable AE HS Target temp smooth
    MBOOL   bEnableAEAblTS;                  // enable AE ABL Target temp smooth
    MBOOL   bEnableAEAoeTS;                  // enable AE AOE Target temp smooth
    MBOOL   bEnableAENsTS;                   // enable AE NS Target temp smooth
    MBOOL   bEnableAEFaceTS;                 // enable AE Face Target temp smooth
    MBOOL   bEnableAEVideoTS;                // enable AE Video Target temp smooth
    MBOOL   bEnableAEMainTargetTS;                // enable AE Main Target temp smooth
    MBOOL   bEnableAEHsV4p0TargetTS;                // enable AE HSV4p0 Target temp smooth
} strAECWRTempSmooth;

/******************************************************************************/
// Feature name : AE Face Landmark
// Use Face Landmark algorithm to locate faces more accurately.
// Variable name: bLandmarkCtrlFlag
// A switch for AE Face Landmark.
// default value: FALSE.
// data range: TRUE or FALSE.
// constraints: N/A.
// effect: Set TRUE to enable AE Face Landmark.
//     
// Variable name: u4LandmarkCV_Thd
// A Threshold for confidence of Face Landmark
// default value: 0.
// data range: Integer, u4LandmarkCV_Thd >= 0.
// constraints: N/A.
// effect: The confidence of one Face Landmark should be over than u4LandmarkCV_Thd or this Face Landmark will
//         not take effect.
// 
// Variable name: u4LandmarkWeight
// The weighting of the Face Landmark
// default value: 3.
// data range: Integer, u4LandmarkWeight >= 0.
// constraints: N/A.
// effect: u4LandmarkWeight will influence final FDY. 
/******************************************************************************/

typedef struct {
    MBOOL   bLandmarkCtrlFlag;              // face landmark ctrol flag
    MUINT32 u4LandmarkCV_Thd;               // face landmark info cv thd
    MUINT32 u4LandmarkWeight;               // face landmark weight
}strFaceLandMarkCtrl;

/******************************************************************************/
// Feature name : AE Converge Tuning Parameters.
//
// Variable name: u4InStableThd.
// A threshold for preview mode from the non-convergent  situation to the convergent situation. u4FinerEvIndexBase base.
// Default value: 0.
// Data range: Integer, u4InStableThd >= 0.
// Constraints: N/A.
// Effect: The lower u4InStableThd is, the more difficult we may achieve the convergent situation.
//
// Variable name: u4OutStableThd.
// A threshold for preview mode from the convergent situation to the non-convergent  situation. u4FinerEvIndexBase base.
// Default value: 1.
// Data range: Integer.
// Constraints: N/A, u4OutStableThd >= 0.
// Effect: If u4OutStableThd > u4InStableThd, it is more difficult to get in the non-convergent situation from 
//         the convergent situation.
//
// Variable name: bEnableAEModeStableTHD.
// A switch for AE Converge.
// Default value: TRUE.
// Data range: TRUE or FALSE.
// Constraints: N/A.
// Effect: Set TRUE to turn on AE Converge for different modes.        
//    
// Variable name: u4VideoInStableThd.
// A threshold for video mode from the non-convergent  situation to the convergent situation. u4FinerEvIndexBase base.
// Default value: 1.
// Data range: Integer, u4VideoInStableThd >= 0.
// Constraints: N/A.
// Effect: The lower u4VideoInStableThd is, the more difficult we may achieve the convergent situation.
//
// Variable name: u4VideoOutStableThd.
// A threshold for video mode from the convergent situation to the non-convergent  situation. u4FinerEvIndexBase base.
// Default value: 1.
// Data range: Integer, u4VideoOutStableThd >= 0.
// Constraints: N/A.
// Effect: If u4VideoOutStableThd > u4VideoInStableThd, it is more difficult to get in the non-convergent situation from 
//         the convergent situation.
//
// Variable name: u4FaceInStableThd.
// A threshold for face mode from the non-convergent  situation to the convergent situation. u4FinerEvIndexBase base.
// Default value: 1.
// Data range: Integer, u4FaceInStableThd >= 0.
// Constraints: N/A.
// Effect: The lower u4FaceInStableThd is, the more difficult we may achieve the convergent situation.
//
// Variable name: u4FaceOutStableThd.
// A threshold for face mode from the convergent situation to the non-convergent  situation. u4FinerEvIndexBase base.
// Default value: 2.
// Data range: Integer, u4FaceOutStableThd >= 0.
// Constraints: N/A.
// Effect: If u4FaceOutStableThd > u4FaceInStableThd, it is more difficult to get in the non-convergent situation from 
//         the convergent situation.
//
// Variable name: u4TouchInStableThd.
// A threshold for touch mode or capture mode from the non-convergent  situation to the convergent situation. u4FinerEvIndexBase base.
// Default value: 1.
// Data range: Integer, u4TouchInStableThd >= 0.
// Constraints: N/A.
// Effect: The lower u4TouchInStableThd is, the more difficult we may achieve the convergent situation.
//
// Variable name: u4TouchOutStableThd.
// A threshold for touch mode or capture mode from the convergent situation to the non-convergent  situation. u4FinerEvIndexBase base.
// Default value: 2.
// Data range: Integer, u4TouchOutStableThd >= 0.
// Constraints: N/A.
// Effect: If u4TouchOutStableThd > u4TouchInStableThd, it is more difficult to get in the non-convergent situation from 
//         the convergent situation.
//
/******************************************************************************/

typedef struct {
    MUINT32 u4InStableThd;  // 0.08EV
    MUINT32 u4OutStableThd; // 0.08EV

    MBOOL   bEnableAEModeStableTHD;         // enable video ae stable threshold setting
    MUINT32 u4VideoInStableThd;               // video mode each index 0.08EV
    MUINT32 u4VideoOutStableThd;              // video mode each index 0.08EV
    MUINT32 u4FaceInStableThd;               // Face mode each index 0.08EV
    MUINT32 u4FaceOutStableThd;              // Face mode each index 0.08EV
    MUINT32 u4FaceOutB2TStableThd;              // Face mode each index 0.08EV
    MUINT32 u4FaceOutD2TStableThd;              // Face mode each index 0.08EV
    MUINT32 u4TouchInStableThd;               // Touch mode each index 0.08EV
    MUINT32 u4TouchOutStableThd;              // Touch mode each index 0.08EV
    MBOOL   bEnableFaceAeLock;               // Face Ae lock option
    MBOOL   bEnableZeroStableThd;            // enable zero stable thd
} strAEStableThd;

/******************************************************************************/
// Feature name : AE Touch Moving Ratio.
// It can determine how large step we can move toward the target.
// Variable name: u4SpeedUpRatio.
// A speedup ratio for AE BV acceleration.
// Default value: 100.
// Data range: Integer, u4SpeedUpRatio >= 0.
// Constraints: N/A.
// Effect: The higher u4SpeedUpRatio is, the larger step we move.
// 
// Variable name: u4GlobalRatio.
// A factor will be multiplied by the final ratio.
// Default value: 100.
// Data range: Integer, u4GlobalRatio >= 0.
// Constraints: N/A.
// Effect: The higher u4GlobalRatio is, the larger step we move.
// 
// Variable name: u4Bright2TargetEnd.
// A end x coordinate in B2T case.
// The start of x coordinate in B2T case depends on CWR.
// Default value: 190
// Data range: Integer, u4Bright2TargetEnd >= 0.
// Constraints: N/A.
//  
// Variable name: u4Dark2TargetStart.
// A start x coordinate in D2T case.
// The end of x coordinate in D2T case depends on CWR.
// Default value: 20
// Data range: Integer, u4Dark2TargetStart >= 0.
// Constraints: N/A.
// 
// Variable name: u4B2TEnd.
// A end y coordinate in B2T case.
// Default value: 80
// Data range: Integer, u4B2TEnd >= 0.
// Constraints: u4B2TEnd > u4B2TStart.
//
// Variable name: u4B2TStart.
// A start y coordinate in B2T case.
// Default value: 60
// Data range: Integer, u4B2TStart >= 0.
// Constraints: u4B2TEnd > u4B2TStart.
// 
// Variable name: u4D2TEnd.
// A end y coordinate in D2T case.
// Default value: 40
// Data range: Integer, u4D2TEnd >= 0.
// Constraints: u4D2TEnd < u4D2TStart.
//
// Variable name: u4D2TStart.
// A start y coordinate in D2T case.
// Default value: 80
// Data range: Integer, u4D2TStart >= 0.
// Constraints: u4D2TEnd < u4D2TStart.
// 
/******************************************************************************/  

typedef struct
{
        MUINT32 u4SpeedUpRatio;
        MUINT32 u4GlobalRatio;
        MUINT32 u4Bright2TargetEnd;
        MUINT32 u4Dark2TargetStart;
        MUINT32 u4B2TEnd;
        MUINT32 u4B2TStart;
        MUINT32 u4D2TEnd;
        MUINT32 u4D2TStart;
} strAEMovingRatio;

/******************************************************************************/
// Feature name : AE HS Sky Enhancement By Real BV.
// We want the target can be higher in HS for sky scene.
// Tuning parameters for HS sky enhancement.
// Variable name: bEnableFlatSkyEnhance.
// A switch for AE HS Sky By Real BV.
// Default value: TRUE.
// Data range: TRUE or FALSE.
// Constraints: N/A.
// Effect: Set TRUE to enable AE HS Sky By Real BV.
// 
// Variable name: uSkyDetInThd.
// A threshold for sky detection from the non-sky scene to the sky scene. 100 base.
// Default value: 2.
// Data range: Integer.
// Constraints: N/A.
// Effect: When it isn't considered as a sky scene, the higher uSkyDetInThd is, the more difficult we may consider it is the sky scene.
// 
// Variable name: uSkyDetOutThd.
// A threshold for sky detection from the sky scene to the non-sky scene. 100 base.
// Default value: 5.
// Data range: Integer.
// Constraints: N/A.
// Effect: When it is considered as a sky scene, the higher uSkyDetOutThd is, the more difficult we may consider it is the non-sky scene.
// 
// Variable name: u4FlatSkyTHD.
// HS sky threshold.
// Default value: 160.
// Data range: Integer, u4FlatSkyTHD >= 0.
// Constraints: N/A.
// Effect: When it is in sky scene, the higher u4FlatSkyTHD is, the higher target in sky scene we have.
// 
// Variable name: u4FlatSkyEVD.
// HS sky EV difference.
// Default value: 1500.
// Data range: Integer, u4FlatSkyEVD >= 0.
// Constraints: N/A.
// Effect: When it is a sky scene and we decrease u4FlatSkyEVD, we may get higher target.
// 
// Variable name: u4BVRatio_X.
// BV range. Used to find the probability for HS_BV. 
// Default value: {8000, 11000}.
// Data range: Integer, u4BVRatio_X[0] >= 0, u4BVRatio_X[1] >= 0. 
// Constraints: u4BVRatio_X[0] <= u4BVRatio_X[1].
// Effect: Find probability according to BV.
// 
// Variable name: u4BVRatio_Y.
// Range of probability according to BV.
// Default value: {0, 1024}.
// Data range: Integer, u4BVRatio_Y[0] >= 0, u4BVRatio_Y[0] >= 0.
// Constraints: u4BVRatio_Y[0] < u4BVRatio_Y[1].
// Effect: The higher entries in the range are, the larger probability we get. 
// 
/******************************************************************************/

typedef struct {
    MBOOL  bEnableFlatSkyEnhance;                                // enable HS adaptive THD by realBV
    MUINT8  uSkyDetInThd;
    MUINT8  uSkyDetOutThd;
    MUINT32 u4FlatSkyTHD;
    MUINT32 u4FlatSkyEVD;
    MINT32 u4BVRatio_X[2];
    MINT32 u4BVRatio_Y[2];
} strHSFlatSkyCFG;

/******************************************************************************/
// Feature name : AE Multiple Step HS.
// Adaptive HS target by real BV.
// Variable name: bEnableMultiStepHS.
// A switch for AE Multiple Step HS.
// Default value: TRUE.
// Data range: TRUE or FALSE.
// Constraints: N/A.
// Effect: Set TRUE to enable AE Multiple Step HS.
// 
// Variable name: u4TblLength.
// How many steps we need.
// Default value: 4.
// Data range: Integer, u4TblLength > 0.
// Constraints: N/A.
// Effect: The larger the u4TblLength is, the more the steps we have, the smaller each step is.
// 
// Variable name: u4MS_EVDiff.
// Range of EV difference. The number of entries should equal to u4TblLength.
// Default value: {1100, 2600, 4500, 6000}.
// Data range: Integer, u4MS_EVDiff[0] >= 0, u4MS_EVDiff[1] >= 0, u4MS_EVDiff[2] >= 0, u4MS_EVDiff[3] >= 0.
// Constraints: Monotonically increasing.
// Effect: We will find target according to EV difference.
//        
// Variable name: u4MS_OutdoorTHD.
// Range of outdoor target. The number of entries should equal to u4TblLength.
// Entries in u4MS_OutdoorTHD >= Entries in u4MS_IndoorTHD.
// Default value: {65, 150, 165, 180}
// Data range: Integer, u4MS_OutdoorTHD[0] >= 0, u4MS_OutdoorTHD[1] >= 0, u4MS_OutdoorTHD[2] >= 0, u4MS_OutdoorTHD[3] >= 0.
// Constraints: Monotonically increasing.
// Effect: High bound range for HS target. We will find HS target according to BV.
//     
// Variable name: u4MS_IndoorTHD.
// Range of indoor target. The number of entries should equal to u4TblLength.
// Entries in u4MS_OutdoorTHD >= Entries in u4MS_IndoorTHD.
// Default value: {65, 140, 150, 165}.
// Data range: Integer, u4MS_IndoorTHD[0] >= 0, u4MS_IndoorTHD[1] >= 0, u4MS_IndoorTHD[2] >= 0, u4MS_IndoorTHD[3] >= 0.
// Constraints: Monotonically increasing.
// Effect: Low bound range for HS target. We will find HS target according to BV.
//         
// Variable name: i4MS_BVRatio.
// Range of BV. We will find the range of target by real BV between this range.
// Default value: {4500, 8000}.
// Data range: Integer, i4MS_BVRatio[0] >= 0, i4MS_BVRatio[1] >= 0.
// Constraints: i4MS_BVRatio[0] < i4MS_BVRatio[1].
// Effect: The target will be found by interpolation between u4MS_OutdoorTHD and u4MS_IndoorTHD using real BV. 
//          
/******************************************************************************/

typedef struct
{
    MBOOL   bEnableMultiStepHS;         //Enable HS enhance method : MultiStep HS(Conflict with ori HS)
    MUINT32 u4TblLength;                                //Max size : 16
    MUINT32 u4MS_EVDiff[AE_RATIOTBL_MAXSIZE];            //size must large than u4TblLength
    MUINT32 u4MS_OutdoorTHD[AE_RATIOTBL_MAXSIZE];        //size must large than u4TblLength
    MUINT32 u4MS_IndoorTHD[AE_RATIOTBL_MAXSIZE];         //size must large than u4TblLength
    MINT32    i4MS_BVRatio[2];                      //MS_HS In/Out door BV threshold
} strHSMultiStep;


/******************************************************************************/
// Feature name : AE Block Histogram Configuration.
// Configuration for AE Block Histogram.
// Variable name: uHist0StartBlockXRatio.
// A ratio for the width for histogram 0.
// Default value: 0.
// Data range: Integer.
// Constraints: N/A.
// Effect: The start x of the block will be multiplied  by uHist0StartBlockXRatio to change the size of the referenced block.
//         Increase uHist0StartBlockXRatio to shrink the referenced block.
// 
// Variable name: uHist0EndBlockXRatio.
// A ratio for the width for histogram 0.
// Default value: 100.
// Data range: Integer.
// Constraints: N/A.
// Effect: The end x of the block will be multiplied  by uHist0EndBlockXRatio to change the size of the referenced block.
//         decrease uHist0EndBlockXRatio to shrink the referenced block.
// 
// Variable name: uHist0StartBlockYRatio.
// A ratio for the height for histogram 0.
// Default value: 0.
// Data range: Integer.
// Constraints: N/A.
// Effect: The start y of the block will be multiplied  by uHist0StartBlockYRatio to change the size of the referenced block.
//         Increase uHist0StartBlockYRatio to shrink the referenced block.
// 
// Variable name: uHist0EndBlockYRatio.
// A ratio for the height for histogram 0.
// Default value: 100.
// Data range: Integer.
// Constraints: N/A.
// Effect: The end y of the block will be multiplied  by uHist0EndBlockYRatio to change the size of the referenced  block.
//         decrease uHist0EndBlockYRatio to shrink the referenced block.
// 
// Variable name: uHist1StartBlockXRatio.
// A ratio for the width for histogram 1.
// Default value: 0.
// Data range: Integer.
// Constraints: N/A.
// Effect: The start x of the block will be multiplied  by uHist1StartBlockXRatio to change the size of the referenced block.
//         Increase uHist1StartBlockXRatio to shrink the referenced block.
// 
// Variable name: uHist1EndBlockXRatio.
// A ratio for the width for histogram 1.
// Default value: 100.
// Data range: Integer.
// Constraints: N/A.
// Effect: The end x of the block will be multiplied  by uHist1EndBlockXRatio to change the size of the referenced block.
//         decrease uHist1EndBlockXRatio to shrink the referenced block.
// 
// Variable name: uHist1StartBlockYRatio.
// A ratio for the height for histogram 1.
// Default value: 0.
// Data range: Integer.
// Constraints: N/A.
// Effect: The start y of the block will be multiplied  by uHist1StartBlockYRatio to change the size of the referenced block.
//         Increase uHist1StartBlockYRatio to shrink the referenced block.
// 
// Variable name: uHist1EndBlockYRatio.
// A ratio for the height for histogram 1.
// Default value: 100.
// Data range: Integer.
// Constraints: N/A.
// Effect: The end y of the block will be multiplied  by uHist1EndBlockYRatio to change the size of the referenced block.
//         decrease uHist1EndBlockYRatio to shrink the referenced block.
// 
// 
// Variable name: uHist2StartBlockXRatio.
// A ratio for the width for histogram 2.
// Default value: 0.
// Data range: Integer.
// Constraints: N/A.
// Effect: The start x of the block will be multiplied  by uHist2StartBlockXRatio to change the size of the referenced block.
//         Increase uHist2StartBlockXRatio to shrink the referenced block.
// 
// Variable name: uHist2EndBlockXRatio.
// A ratio for the width for histogram 2.
// Default value: 100.
// Data range: Integer.
// Constraints: N/A.
// Effect: The end x of the block will be multiplied  by uHist2EndBlockXRatio to change the size of the referenced block.
//         decrease uHist2EndBlockXRatio to shrink the referenced block.
// 
// Variable name: uHist2StartBlockYRatio.
// A ratio for the height for histogram 2.
// Default value: 0.
// Data range: Integer.
// Constraints: N/A.
// Effect: The start y of the block will be multiplied  by uHist2StartBlockYRatio to change the size of the referenced block.
//         Increase uHist2StartBlockYRatio to shrink the referenced block.
// 
// Variable name: uHist2EndBlockYRatio.
// A ratio for the height for histogram 2.
// Default value: 100.
// Data range: Integer.
// Constraints: N/A.
// Effect: The end y of the block will be multiplied  by uHist2EndBlockYRatio to change the size of the referenced block.
//         decrease uHist2EndBlockYRatio to shrink the referenced block.
// 
// Variable name: uHist3StartBlockXRatio.
// A ratio for the width for histogram 3.
// Default value: 25.
// Data range: Integer.
// Constraints: N/A.
// Effect: The start x of the block will be multiplied  by uHist3StartBlockXRatio to change the size of the referenced block.
//         Increase uHist3StartBlockXRatio to shrink the referenced block.
// 
// Variable name: uHist3EndBlockXRatio.
// A ratio for the width for histogram 3.
// Default value: 75.
// Data range: Integer.
// Constraints: N/A.
// Effect: The end x of the block will be multiplied  by uHist3EndBlockXRatio to change the size of the referenced block.
//         decrease uHist3EndBlockXRatio to shrink the referenced block.
// 
// Variable name: uHist3StartBlockYRatio.
// A ratio for the height for histogram 3.
// Default value: 25.
// Data range: Integer.
// Constraints: N/A.
// Effect: The start y of the block will be multiplied  by uHist3StartBlockYRatio to change the size of the referenced block.
//         Increase uHist3StartBlockYRatio to shrink the referenced block.
// 
// Variable name: uHist3EndBlockYRatio.
// A ratio for the height for histogram 3.
// Default value: 75.
// Data range: Integer.
// Constraints: N/A.
// Effect: The end y of the block will be multiplied  by uHist3EndBlockYRatio to change the size of the referenced block.
//         decrease uHist3EndBlockYRatio to shrink the referenced block.
// 
/******************************************************************************/

typedef struct
{
    MUINT8 uHist0StartBlockXRatio;       //Histogram 0 window config start block X ratio (0~100)
    MUINT8 uHist0EndBlockXRatio;         //Histogram 0 window config end block X ratio (0~100)
    MUINT8 uHist0StartBlockYRatio;       //Histogram 0 window config start block Y ratio (0~100)
    MUINT8 uHist0EndBlockYRatio;         //Histogram 0 window config end block Y ratio (0~100)
    MUINT8 uHist0OutputMode;               //Histogram 0 output source mode
    MUINT8 uHist0BinMode;                    //Histogram 0 bin mode range
    MUINT8 uHist1StartBlockXRatio;       //Histogram 1 window config start block X ratio (0~100)
    MUINT8 uHist1EndBlockXRatio;         //Histogram 1 window config end block X ratio (0~100)
    MUINT8 uHist1StartBlockYRatio;       //Histogram 1 window config start block Y ratio (0~100)
    MUINT8 uHist1EndBlockYRatio;         //Histogram 1 window config end block Y ratio (0~100)
    MUINT8 uHist1OutputMode;               //Histogram 1 output source mode
    MUINT8 uHist1BinMode;                    //Histogram 1 bin mode range
    MUINT8 uHist2StartBlockXRatio;       //Histogram 2 window config start block X ratio (0~100)
    MUINT8 uHist2EndBlockXRatio;         //Histogram 2 window config end block X ratio (0~100)
    MUINT8 uHist2StartBlockYRatio;       //Histogram 2 window config start block Y ratio (0~100)
    MUINT8 uHist2EndBlockYRatio;         //Histogram 2 window config end block Y ratio (0~100)
    MUINT8 uHist2OutputMode;               //Histogram 2 output source mode
    MUINT8 uHist2BinMode;                    //Histogram 2 bin mode range
    MUINT8 uHist3StartBlockXRatio;       //Histogram 3 window config start block X ratio (0~100)
    MUINT8 uHist3EndBlockXRatio;         //Histogram 3 window config end block X ratio (0~100)
    MUINT8 uHist3StartBlockYRatio;       //Histogram 3 window config start block Y ratio (0~100)
    MUINT8 uHist3EndBlockYRatio;         //Histogram 3 window config end block Y ratio (0~100)
    MUINT8 uHist3OutputMode;               //Histogram 3 output source mode
    MUINT8 uHist3BinMode;                      //Histogram 3 bin mode range
} AE_HIST_WIN_CFG_T;

/******************************************************************************/
// Feature name : AE AOE By BV.
// Adaptive AOE target by BV.
// Variable name: bEnable.
// A switch for AE AOE By BV.
// Default value: TRUE.
// Data range: TRUE or FALSE.
// Constraints: N/A.
// Effect: Set TRUE to enable AE Multiple Step AOE.
// 
// Variable name: u4TblLength.
// How many steps we need.
// Default value: 4.
// Data range: Integer, u4TblLength > 0.
// Constraints: N/A.
// Effect: The larger the u4TblLength is, the more the steps are, the smaller each step is.
//
// Variable name: i4BV.
// Range of BV. We will find AOE target by real BV.
// Default value: {-2000, 0, 3000, 5500}.
// Data range: Integer.
// Constraints: Monotonically increasing.
// Effect: We will find AOE target by real BV.
//
// Variable name: u4THD.
// Range of AOE target. We will find AOE target by real BV.
// Default value: {150, 170, 180, 180}.
// Data range: Integer, u4THD[0] >= 0, u4THD[1] >= 0, u4THD[2] >= 0, u4THD[3] >= 0.
// Constraints: Increasing.
// Effect: The entries in i4BV map to entries in u4THD. We will find AOE target by real BV.
//
/******************************************************************************/

typedef struct
{
    MBOOL   bEnable;                        //enable adaptive AOE THD
    MUINT32 u4TblLength;
    MINT32 i4BV[16];
    MUINT32 u4THD[16];
} strAOEBVRef;

/******************************************************************************/
// Feature name : AE Absolute Difference ABL.
// Dark corner buildings can be brighter by turning on this feature. 
// Variable name: bEnableABLabsDiff.
// A switch for AE Absolute Difference ABL.
// Default value: TRUE.
// Data range: TRUE or FALSE.
// Constraints: N/A.
// Effect: Set TRUE to enable AE Absolute Difference ABL.
// 
// Variable name: u4EVDiffRatio_X.
// Range of EV difference. 
// Default value: {2500, 5000}.
// Data range: Integer.
// Constraints: u4EVDiffRatio_X[0] < u4EVDiffRatio_X[1].
// Effect: We will get probability by EV difference.
//
// Variable name: u4EVDiffRatio_Y.
// Range of probability according to absolute EV difference.
// Default value: {0, 1024}.
// Data range: Integer, 0 <= u4EVDiffRatio_Y[0] <= 1024, 0 <= u4EVDiffRatio_Y[1] <= 1024.
// Constraints: u4EVDiffRatio_Y[0] < u4EVDiffRatio_Y[1].
// Effect: The higher entries in the range are, the larger probability we get. 
// 
// Variable name: u4BVRatio_X.
// Range of BV. 
// Default value: {9000, 11000}.
// Data range: Integer.
// Constraints: u4BVRatio_X[0] < u4BVRatio_X[1].
// Effect: We will get probability by BV.
//
// Variable name: u4BVRatio_Y.
// Range of probability according to BV.
// Default {0, 1024}.
// Data range: Integer, 0 <= u4BVRatio_Y[0] <= 1024, 0 <= u4BVRatio_Y[1] <= 1024.
// Constraints: u4BVRatio_Y[0] < u4BVRatio_Y[1].
// Effect: The higher entries in the range are, the larger probability we get. 
// 
/******************************************************************************/  

typedef struct {
    MBOOL bEnableABLabsDiff;                                // enable enhance ABL(absDiff)
    MINT32  u4EVDiffRatio_X[2];
    MINT32  u4EVDiffRatio_Y[2];
    MINT32  u4BVRatio_X[2];
    MINT32  u4BVRatio_Y[2];
} strABL_absDiff;

/******************************************************************************/
// Feature name : AE NS CDF.
// Add CDF for AE NS detection. 
// Variable name: bEnable.
// A switch for AE NS CDF.
// Default value: TRUE.
// Data range: TRUE or FALSE.
// Constraints: N/A.
// Effect: Set TRUE to enable AE NS CDF.
// 
// Variable name: u4Pcent.
// Percentage of number of pixels from the left hand side of the histogram will be referenced. 1000 base.
// Default value: 600.
// Data range: Integer, 0 <= u4Pcent <= 1000.
// Constraints: N/A.
// Effect: The lower u4Pcent is, the easier one scene will be considered as NS.
// 
// Variable name: i4NS_CDFRatio_X.
// Range of CDF BV. We will get the probability of CDF by i4NS_CDFRatio_X.
// Default value: {-1000, -300}.
// Data range: Integer.
// Constraints: i4NS_CDFRatio_X[0] < i4NS_CDFRatio_X[1].
// Effect: The smaller the entries in the range are, the smaller the probability we get.
// 
// Variable name: u4NS_CDFRatio_Y.
// Range of probability according to i4NS_CDFRatio_X.
// Default value: {1024, 0}.
// Data range: Integer, 0 <= u4NS_CDFRatio_Y[0] <= 1024, 0 <= u4NS_CDFRatio_Y[1] <= 1024.
// Constraints: u4NS_CDFRatio_Y[0] > u4NS_CDFRatio_Y[1].
// Effect: The smaller the entries in the range are, the smaller the probability we get.
// 
/******************************************************************************/

typedef struct
{
    MBOOL   bEnable;            //enable NS CDF
    UINT32  u4Pcent;            // 1=0.1%, 0~1000
    MINT32 i4NS_CDFRatio_X[2];
    MUINT32 u4NS_CDFRatio_Y[2];
} strNS_CDF;

/******************************************************************************/
// Feature name : AE Histogram Stable.
// Add AE Histogram Stable mechanism. 
// Variable name: bEnableStablebyHist.
// A switch for AE Histogram Stable.
// Default value: FALSE.
// Data range: TRUE or FALSE.
// Constraints: N/A.
// Effect: Set TRUE to enable AE Histogram Stable.
// 
// Variable name: u4HistEVDiff.
// A threshold for AE Histogram Stable. 1000 base.
// Default value: 250.
// Data range: Integer, u4HistEVDiff >= 0.
// Constraints: N/A.
// Effect: If the EV difference is larger than u4HistEVDiff, we will think it isn't stable. 
// 
// Variable name: u4OverexpoTHD.
// Over-exposure threshold for AE Histogram Stable.
// Default value: 242.
// Data range: Integer, 0 <= u4OverexpoTHD < 256.
// Constraints: N/A.
// Effect: Pixels with value over u4OverexpoTHD are considered into AE Histogram Stable.
//          
// Variable name: u4UnderexpoTHD.
// Under-exposure threshold for AE Histogram Stable.
// Default value: 13.
// Data range: Integer, 0 <= u4UnderexpoTHD < 256.
// Constraints: N/A.
// Effect: Pixels with value below u4UnderexpoTHD are considered into AE Histogram Stable.
//  
// Variable name: u4HistStableTHD.
// Stable threshold for AE Histogram Stable. 1024 base.
// Default value: 140.
// Data range: Integer, u4HistStableTHD >= 0.
// Constraints: N/A.
// Effect: The larger u4HistStableTHD is, the easier we may consider it is stable.
// 
/******************************************************************************/

typedef struct {
    MBOOL bEnableStablebyHist;
    MUINT32 u4HistEVDiff;
    MUINT32 u4OverexpoTHD;
    MUINT32 u4UnderexpoTHD;
    MUINT32 u4HistStableTHD;
} strHistStableCFG;

/******************************************************************************/
// Feature name : AE Over-exposure AOE.
// Add AE Over-exposure AOE to enhance the effect of AOE. 
// Variable name: bEnableOverExpoAOE.
// A switch for AE Over-exposure AOE.
// Default value: TRUE.
// Data range: TRUE or FALSE.
// Constraints: N/A.
// Effect: Set TRUE to enable AE Over-exposure AOE to enhance the effect of AOE. 
// 
// Variable name: u4OElevel.
// Strength of suppressing over-exposure scene.
// Default value: 6.
// Data range: Integer, u4OElevel >= 0.
// Constraints: N/A.
// Effect: The higher u4OElevel is, the bigger the strength of suppressing over-exposure scene is.
// 
// Variable name: u4OERatio_LowBnd.
// The low bound of over-exposure area.
// Default value: 2.
// Data range: Integer, u4OERatio_LowBnd >= 0.
// Constraints: u4OERatio_LowBnd < u4OERatio_HighBnd.
// Effect: The smaller u4OERatio_LowBnd is, the larger the AOE weight is.
// 
// Variable name: u4OERatio_HighBnd.
// The high bound of over-exposure area.
// Default value: 20.
// Data range: Integer, u4OERatio_HighBnd >= 0.
// Constraints: u4OERatio_LowBnd < u4OERatio_HighBnd.
// Effect: The larger u4OERatio_HighBnd is, the smaller the AOE weight is.
// 
// Variable name: i4OE_BVRatio_X.
// Range of BV. We will get the probability of BV by i4OE_BVRatio_X.
// Default value: {4000, 6000}.
// Data range: Integer, i4OE_BVRatio_X[0] >= 0, i4OE_BVRatio_X[1] >= 0.
// Constraints: i4OE_BVRatio_X[0] < i4OE_BVRatio_X[1].
// Effect: The smaller the entries in the range are, the larger the probability we get.
// 
// Variable name: u4OE_BVRatio_Y.
// Range of probability according to i4OE_BVRatio_X.
// Default value: {0, 1024}.
// Data range: Integer, 0 <= u4OE_BVRatio_Y[0] <= 1024, 0 <= u4OE_BVRatio_Y[1] <= 1024.
// Constraints: u4OE_BVRatio_Y[0] < u4OE_BVRatio_Y[1].
// Effect: The smaller the entries in the range are, the smaller the probability we get.
// 
// Variable name: u4OEWeight.
// A weighting for over-exposure count.
// Default value: N/A.
// Data range: N/A.
// Constraints: N/A.
// Effect: Determine which parts we may consider more important.
/******************************************************************************/

typedef struct {
    MBOOL bEnableOverExpoAOE;
    MUINT32 u4OElevel;
    MUINT32 u4OERatio_LowBnd;
    MUINT32 u4OERatio_HighBnd;
    MINT32 i4OE_BVRatio_X[2];
    MUINT32 u4OE_BVRatio_Y[2];
    MUINT32 u4OEWeight[AE_V4P0_BLOCK_NO][AE_V4P0_BLOCK_NO];
} strOverExpoAOECFG;

/******************************************************************************/
// Feature name : AE Main Target.
// AEv4p0 main target tuning function. 
// Variable name: bEnableAEMainTarget.
// A switch for AE Main Target.
// Default value: TRUE.
// Data range: TRUE or FALSE.
// Constraints: N/A.
// Effect: Set TRUE to enable AE Main Target function. 
// 
// Variable name: u4MainTargetWeight.
// The weighting of main target.
// Default value: 1024.
// Data range: Integer, u4MainTargetWeight >= 0.
// Constraints: N/A.
// Effect:
// 
// Variable name: u4MainTargetWeightTbl[15][15].
// The block base 15x15 weight array.
// Default value:
// Data range: Integer, Weight >= 0.
// Constraints: N/A.
// Effect: The block with higher value will contribute on target more than others.
//
// Variable name: TargetBVRatioTbl.
// The LUT which AE target according to realBV.
// Default value:
// Data range: Integer.
// Constraints: TargetBVRatioTbl.i4X2 >= TargetBVRatioTbl.i4X1(realBV).
// Effect:
//
// Variable name: bEnableColorWTRatio.
// A switch for dynamic weight ratio.
// Default value: FALSE
// Data range: TRUE or FALSE.
// Constraints: N/A.
// Effect: Set TRUE to enable ColorWTRatio.
//
// Variable name: ColorWTRatioTbl.
// The LUT with Main target weight according by color difference.
// Default value:
// Data range: Integer, Weight >= 0.
// Constraints: ColorWTRatioTbl.i4X2 >= ColorWTRatioTbl.i4Y1.
// Effect: Adjust weighting for reduce Main Target weight
//
// Variable name: bEnableColorSuppressR/G/B.
// The boolean parameter to control R/G/B suppression.
// Default value:
// Data range: TRUE or FALSE
// Constraints: N/A.
// Effect: Set TRUE to suppress each channel overexpose
/******************************************************************************/

typedef struct {
    MBOOL bEnableAEMainTarget;
    MUINT32 u4MainTargetWeight;     //weight 1024 base
    MUINT32 u4MainTargetWeightTbl[AE_V4P0_BLOCK_NO][AE_V4P0_BLOCK_NO];  //15x15 Gau weight table
    AE_TARGET_PROB_T TargetBVRatioTbl;
    MBOOL bEnableColorWTRatio;
    AE_TARGET_PROB_T ColorWTRatioTbl;
    MBOOL bEnableColorSuppressR;
    MBOOL bEnableColorSuppressG;
    MBOOL bEnableColorSuppressB;
} strMainTargetCFG;

/******************************************************************************/
// Feature name : AE Histogram Stretch v4p0.
// AEv4p0 HS tuning function. 
// Variable name: bEnableHSv4p0.
// A switch for AE HS v4p0.
// Default value: TRUE.
// Data range: TRUE or FALSE.
// Constraints: N/A.
// Effect: Set TRUE to enable AE HS v4p0. 
// 
// Variable name: u4HSv4p0Weight.
// the weighting of HS v4p0.
// Default value: 1024.
// Data range: Integer, u4HSv4p0Weight >= 0.
// Constraints: N/A.
// Effect:
// 
// Variable name: u4BVSize.
// the maximum size of BV array.
// Default value: 3.
// Data range: Integer, u4BVSize > 0.
// Constraints: N/A.
// Effect:
//
// Variable name: u4EVDSize.
// the maximum size of EVD array.
// Default value: 4.
// Data range: Integer, u4EVDSize > 0.
// Constraints: N/A.
// Effect:
//
// Variable name: i4HS_BVRatio.
// Range of realBV. The number of entries should equal to u4BVSize.
// Default value: {1000, 4500, 8000}.
// Data range: Integer.
// Constraints: Increment.
// Effect:
//
// Variable name: u4HS_PcntRatio.
// Range of Histogram percentage. The number of entries should equal to u4BVSize.
// Default value: {80,60,20}.
// Data range: Integer, u4HS_PcntRatio[i] > 0.
// Constraints: N/A.
// Effect: Increase the percentage value will get the brighter exposure. 
//
// Variable name: u4HS_EVDRatio.
// Range of EV Difference. The number of entries should equal to u4EVDSize.
// Default value: {1100, 2600, 4000,6500}.
// Data range: Integer, u4HS_EVDRatio[i] > 0.
// Constraints: Increment.
// Effect:
//
// Variable name: u4HSTHDRatioTbl.
// 2D LUT with HS threshold according by realBV and EV Difference.
// Default value:
// Data range: Integer, u4HSTHDRatioTbl[i][j] >= 0.
// Constraints: Increment.
// Effect: Increase the threshold will get the brighter exposure.
//
// Variable name: bEnableDynWTRatio.
// A switch for dynamic weight ratio.
// Default value: TRUE.
// Data range: TRUE or FALSE.
// Constraints: N/A.
// Effect: Set TRUE to enable HS dynamic weight control.
//
// Variable name: DynWTRatioTbl.
// the LUT with HS v4p0 weight according by threshold difference.
// Default value:
// Data range: Integer, Weight & threshold difference >= 0.
// Constraints: N/A.
// Effect: large weighting gain will increase HS v4p0 weight.
/******************************************************************************/

typedef struct {
    MBOOL bEnableHSv4p0;
    MUINT32 u4HSv4p0Weight;     //weight 1024 base
    MUINT32 u4BVSize;      //max size 16
    MUINT32 u4EVDSize;   //max size 16
    MINT32 i4HS_BVRatio[AE_RATIOTBL_MAXSIZE];            //Ratio[uBVSize]
    MUINT32 u4HS_PcntRatio[AE_RATIOTBL_MAXSIZE];     //Ratio[uBVSize]
    MUINT32 u4HS_EVDRatio[AE_RATIOTBL_MAXSIZE];     //Ratio[u4EVDSize]
    MUINT32 u4HSTHDRatioTbl[AE_RATIOTBL_MAXSIZE][AE_RATIOTBL_MAXSIZE]; //RatioTbl[uBVSize][uEVDSize]
    MBOOL bEnableDynWTRatio;
    AE_TARGET_PROB_T DynWTRatioTbl;
} strHSv4p0CFG;

/******************************************************************************/
// Feature name : Dynamic Flare smooth
//
// Variable name: u4FlareSmallDeltaIdxStep
// Flare offset speed when AE is closed to stable.
// Data range: 1~8
// Effect: 1 will get the smoothest flare offset result but spends more time and 8 is the opposite result
//
// Variable name: u4CWVChangeStep
// Flare offset speed when AE is table but the CWV is still changing, which means the scene is changing
// Data range: 1~8
// Effect: 1 will get the smoothest flare offset result but spends more time and 8 is the opposite result
//
// Variable name: u4AllStableStep
// Flare offset speed when AE  and the CWV is stable, we hope this tuning parameter is small
// Data range: 1~4
// Effect: 1 will get the smoothest flare offset result but spends more time and 8 is the opposite result
// 
/******************************************************************************/

typedef struct {
    UINT32 u4FlareSmallDeltaIdxStep;
    UINT32 u4CWVChangeStep;
    UINT32 u4AllStableStep;
} strDynamicFlare;

struct AE_PARAMETER
{
    strAEParamCFG strAEParasetting;
    strWeightTable *pWeighting[MAX_WEIGHT_TABLE];   //AE WEIGHTING TABLE
    strAFPlineInfo strAFPLine;
    strAFPlineInfo strAFZSDPLine;
    strAFPlineInfo strStrobePLine;
    strAFPlineInfo strStrobeZSDPLine;
    MUINT32 *pEVValueArray;
    strAEMOVE *pAEMovingTable;
    strAEMOVE *pAEVideoMovingTable;
    strAEMOVE *pAEFaceMovingTable;
    strAEMOVE *pAETrackingMovingTable;
    strAELimiterTable strAELimiterData;
    VdoDynamicFrameRate_T strVdoDFps;

    AE_HIST_WIN_CFG_T *pAEBlockWINCFG;
    AE_HIST_WIN_CFG_T *pAEPixelWINCFG;
    // v1.2
    MBOOL   bOldAESmooth;                          // Select the new or old AE smooth control
    /******************************************************************************/
    // Variable name: bEnableSubPreIndex
    // A switch for enabling use of previous EV index in SUB CAM. 
    // Scenario: Leave camera app and return to camera app. There are 2 option. One is previous index the other is u4InitIndex. 
    // Default value: TRUE.
    // Data range: N/A.
    // Constraints: N/A.
    // Effect : Set TRUE to enable use of previous EV index.
    // 
    /******************************************************************************/
    MBOOL   bEnableSubPreIndex;                // decide the sub camera re-initial index after come back to camera
    /******************************************************************************/
    // Feature name : Video LPF Weight.
    // 
    // Variable name: u4VideoLPFWeight.
    // A weighting for current central weighting value and previous one in sensor video mode.
    // Default value: 0.
    // Data range: 0~23.
    // Constraints: Max:23, Min:0.
    // Effect: The higher u4VideoLPFWeight is, the larger percentage of current central weighting 
    //         value we have.        
    //         
    /******************************************************************************/
    MUINT32 u4VideoLPFWeight; // 0~24

    strFaceLocSize *pFaceLocSizecheck;
    strPerframeCFG *pPerframeCFG;
    /******************************************************************************/
    // Feature name : Perframe Smooth.
    // 
    // Variable name: bPerFrameAESmooth.
    // A switch for Perframe Smooth.
    // Default value: TRUE.
    // Data range: TRUE or FALSE.
    // Constraints: N/A.
    // Effect: Set TRUE to turn on Perframe Smooth for AE.        
    //         
    /******************************************************************************/
    MBOOL   bPerFrameAESmooth;                    // Perframe AE smooth option
    MBOOL   bPerFrameHDRAESmooth;                    // Perframe AE smooth option
    /******************************************************************************/
    // Feature name : TG Speedup.
    // 
    // Variable name: bTgIntAEEn.
    // A switch for TG speedup.
    // Default value: FALSE.
    // Data range: TRUE or FALSE.
    // Constraints: N/A.
    // Effect: Set TRUE to turn on TG speedup mechanism.
    //
    // Variable name: bSpeedupEscOverExp.
    // A switch for TG speedup escape from over-exposure segment.
    // Default value: TRUE.
    // Data range: TRUE or FALSE.
    // Constraints: When bTgIntAEEn is TRUE, this variable can take effect.
    // Effect: Set TRUE to turn on TG speedup escape from over-exposure segment mechanism.
    //
    // Variable name: bSpeedupEscUnderExp.
    // A switch for TG speedup escape from under-exposure segment.
    // Default value: FALSE.
    // Data range: TRUE or FALSE.
    // Constraints: When bTgIntAEEn is TRUE, this variable can take effect.
    // Effect: Set TRUE to turn on TG speedup escape from under-exposure segment mechanism.
    //
    // Variable name: pAETgTuningParam.
    // Tuning parameters for TG speedup.
    // Details are listed in its definition.
    //
    // Variable name: pTgEVCompJumpRatioOverExp.
    // A LUT to for EV compensation in over-exposure segment.
    // Default value: N/A.
    // Data range: Integer.
    // Constraints: N/A.
    // Effect: Decide the ratio of delta index we move in over-exposure segment.
    //
    // Variable name: pTgEVCompJumpRatioUnderExp.
    // A LUT to for EV compensation in under-exposure segment.
    // Default value: N/A.
    // Data range: Integer.
    // Constraints: N/A.
    // Effect: Decide the ratio of delta index we move in under-exposure segment.
    //
    // Variable name: pTgWeightTbl.
    // A weighting table for raw data in TG.
    // Raw data is divided into 9x12 blocks.
    // Default value: N/A.
    // Data range: R.
    // Constraints: N/A.
    // Effect: Used to compute central weighting value in TG.
    //
    /******************************************************************************/
    // TG interrupt
    MBOOL   bTgIntAEEn;                    // TG interrupt option
    MBOOL   bSpeedupEscOverExp;
    MBOOL   bSpeedupEscUnderExp;
    strAETgTuningPara *pAETgTuningParam;
    MINT32 *pTgEVCompJumpRatioOverExp;
    MINT32 *pTgEVCompJumpRatioUnderExp;
    MUINT32 pTgWeightTbl[9][12];

    //Open AE
    strAEStableThd *pAEStableThd;
    strBVAccRatio   *pBVAccRatio;              // Preview ACC ratio
    strPSOConverge *pPSOConverge;
    strNonCWRAcc    *pNonCWRAcc;
    strFaceSmooth  *pFaceSmooth;
    strFaceWeight  *pFaceWeight;
    strAECWRTempSmooth  *pAETempSmooth;
    strFaceLandMarkCtrl *pFaceLandmark;
    strAOEBVRef     *pAOERefBV;
    strNS_CDF       *pNsCdfRatio;

    //v2.5
    strAEMovingRatio *pAETouchMovingRatio;   //(temp) Touch smooth ratio
    strHSFlatSkyCFG     *pHSFlatSkyEnhance; //HS adaptive Prob Threshold by real BV
    strABL_absDiff      *pABLabsDiff;
    //v3.0
    strHSMultiStep    *pHSMultiStep;
    strHistStableCFG  *pHistStableCFG;
    strOverExpoAOECFG *pOverExpoAOECFG;
    //v4.0
    MBOOL bAEv4p0MeterEnable;
    strMainTargetCFG *pMainTargetCFG;
    strHSv4p0CFG *pHSv4p0CFG;
    strNSBVCFG *pNSBVCFG;

    // HDR
    HDR_AE_PARAM_T    *pHdrAECFG;

    // Stereo Pline mapping
    strAESceneMapping strStereoPlineMapping;
    // HDR Pline mapping
    strAESceneMapping strHDRPlineMapping;

    //Dynamic Flare
    strDynamicFlare *pDynamicFlareCFG;

};

static HDR_AE_PARAM_T g_strHdrAECFG =
    {
        eHDRPARAM_ID    eHdrParamID;

        /**************************************************/
        // Feature name: HDR detector parameter information
        // HDR detector will turn HDR ON if the HDR probability results of histogram, geometry, LV exceed threshold
        // rHdrDetector
        /**************************************************/
        {
            /**************************************************/
            // Variable name: bHdrDetectorEnable
            // A switch to turn on/off of HDR detector
            // Default value: MTRUE.
            // Data range: MTRUE or MFALSE.
            // Constraints: N/A.
            // Effect: Set TRUE to enable HDR detector
            //
            // Variable name: i4HdrConfidenceThr
            // Threshold to turn HDR on/off
            // Unit: %
            // Default value: 80 or 220
            // Data range: Integer, i4HdrConfidenceThr > 0
            // Constraints: N/A.
            // Effect: Turn HDR on when result of HDR scene probability is larger than i4HdrConfidenceThr
            /**************************************************/
            BOOL    bHdrDetectorEnable;
            MINT32  i4HdrConfidenceThr;

            /**************************************************/
            // Feature name: rHdrHistInfo
            // HDR detector - histogram information calculation
            // Detect HDR scene by calculating full RGB histogram information
            // Find the proportion of pixel at bright/dark side of an image to check HDR characteristics in histogram
            /**************************************************/
            {
                /**************************************************/
                // Variable name: bHistDetectEnable
                // A switch to turn on/off histogram analysis of HDR detector
                // Default value: TRUE.
                // Data range: TRUE or FALSE.
                // Constraints: N/A.
                // Effect: Set TRUE to enable histogram analysis of HDR detector
                /**************************************************/
                MBOOL   bHistDetectEnable;

                /**************************************************/
                // Feature name: HDR detector - dark weight
                // Dark side weighting table for HDR detector
                // Multiply full RGB histogram with dark side weight and add the result of bright side to find HDR histogram probability
                // Here are the parameters to control the HDR ON sensitivity to the dark part of image
                // A pixel will be treated as a dark pixel, if its pixel value is lower than certain threshold
                // Here are the parameters to control the threshold of dark pixel and the corresponding weighting
                // rHdrDetectDarkWtWin
                //
                // Variable name: i4HdrHistP0
                // Dark side histogram bin threshold to full weight
                // Unit: Y value in 8 bits
                // Default value: 6
                // Data range: Integer, 0 < i4HdrHistP0 < i4HdrHistP1
                // Constraints: N/A.
                // Effect: The higher i4HdrHistP0, the more histogram bins are taken into fully consideration
                //
                // Variable name: i4HdrHistP1
                // Dark side histogram bin threshold to partial weight
                // Unit: Y value in 8 bits
                // Default value: 12
                // Data range: Integer, i4HdrHistP0 < i4HdrHistP1 <= 255
                // Constraints: N/A.
                // Effect: The higher i4HdrHistP1, the more histogram bins are taken into partial consideration
                //
                // Variable name: i4HdrHistW0
                // Dark side higher pixel weight
                // Default value: 100
                // Data range: Integer, 0 < i4HdrHistW1 < i4HdrHistW0
                // Constraints: N/A.
                // Effect: The higher i4HdrHistW0, bins before i4HdrHistP0 will get higher fully weight
                //
                // Variable name: i4HdrHistW1
                // Dark side lower pixel weight
                // Default value: 0
                // Data range: Integer, 0 < i4HdrHistW1 < i4HdrHistW0
                // Constraints: N/A.
                // Effect: The higher i4HdrHistW1, bins between (i4HdrHistP0, i4HdrHistP1) will get higher partial weight
                /**************************************************/
                {            
                    // rHdrDetectDarkWtWin
                    MINT32  i4HdrHistP0;
                    MINT32  i4HdrHistP1;
                    MINT32  i4HdrHistW0;
                    MINT32  i4HdrHistW1;
                },

                /**************************************************/
                // Feature name: HDR detector - bright weight
                // Bright side weighting table for HDR detector
                // Multiply full RGB histogram with bright side weight and add the result of dark side to find HDR histogram probability
                // Here are the parameters to control the HDR ON sensitivity to the bright part of image
                // A pixel will be treated as a bright pixel, if its pixel value is higher than certain threshold
                // Influence: HDR probability, HDR on/off
                // rHdrDetectBrightWtWin
                //
                // Variable name: i4HdrHistP0
                // Bright side histogram bin threshold to partial weight
                // Unit: Y value in 8 bits
                // Default value: 180
                // Data range: Integer, 0 ~ 255
                // Constraints: N/A.
                // Effect: The higher i4HdrHistP0, the fewer histogram bins are taken into partial consideration
                //
                // Variable name: i4HdrHistP1
                // Bright side histogram bin threshold to full weight
                // Unit: Y value in 8 bits
                // Default value: 220
                // Data range: Integer, 0 ~ 255
                // Constraints: N/A.
                // Effect: The higher i4HdrHistP1, the fewer histogram bins are taken into fully consideration
                //
                // Variable name: i4HdrHistW0
                // Bright side lower pixel weight
                // Default value: 0
                // Data range: Integer, i4HdrHistW0 <i4HdrHistW1
                // Constraints: N/A.
                // Effect: The higher i4HdrHistW0, bins between (i4HdrHistP0, i4HdrHistP1) will get higher partial weight
                //
                // Variable name: i4HdrHistW1
                // Bright side higher pixel weight
                // Default value: 300
                // Data range: Integer, i4HdrHistW0 <i4HdrHistW1
                // Constraints: N/A.
                // Effect: The higher i4HdrHistW1, bins after i4HdrHistP1 will get higher fully weight
                /**************************************************/
                {               
                    // rHdrDetectBrightWtWin
                    MINT32  i4HdrHistP0;
                    MINT32  i4HdrHistP1;
                    MINT32  i4HdrHistW0;
                    MINT32  i4HdrHistW1;  
                },

                /**************************************************/
                // Feature name: HDR auto enhance bright weight
                // Weighting table, enhance histogram bright side
                // Multiply full RGB histogram with the bright side weight
                // It is used to calculate bright enhance probability
                // Influence: HDR auto weight, HDR ratio
                // rHdrEnhanceBrightWtWin
                //
                // Variable name: i4HdrHistP0
                // Bright side histogram bin threshold to partial weight
                // Unit: Y value in 8 bits
                // Default value: 220
                // Data range: Integer, 0 ~ 255
                // Constraints: N/A.
                // Effect: The higher i4HdrHistP0, the fewer histogram bins are taken into partial consideration
                //
                // Variable name: i4HdrHistP1
                // Bright side histogram bin threshold to full weight
                // Unit: Y value in 8 bits
                // Default value: 245
                // Data range: Integer, 0 ~ 255
                // Constraints: N/A.
                // Effect: The higher i4HdrHistP1, the fewer histogram bins are taken into fully consideration
                //
                // Variable name: i4HdrHistW0
                // Bright side lower pixel weight
                // Default value: 0
                // Data range: Integer, 0 < i4HdrHistW0 <i4HdrHistW1
                // Constraints: N/A.
                // Effect: The higher i4HdrHistW0, bins between (i4HdrHistP0, i4HdrHistP1) will get higher partial weight
                //
                // Variable name: i4HdrHistW1
                // Bright side higher pixel weight
                // Default value: 300
                // Data range: Integer, i4HdrHistW0 <i4HdrHistW1
                // Constraints: N/A.
                // Effect: The higher i4HdrHistW1, bins after i4HdrHistP1 will get higher fully weight
                /**************************************************/
                {               
                    // rHdrEnhanceBrightWtWin
                    MINT32  i4HdrHistP0;
                    MINT32  i4HdrHistP1;
                    MINT32  i4HdrHistW0;
                    MINT32  i4HdrHistW1;
                },

                /**************************************************/
                // Feature name: rHdrFDBrightWtWin
                // Histogram from bright side weighting table for face detection
                // Multiply full RGB histogram with the face detection bright side weight
                // It is used to calculate face detection bright tone probability
                // Influence: HDR face probability
                // rHdrFDBrightWtWin
                //
                // Variable name: i4HdrHistP0
                // Face detection bright side histogram bin threshold to partial weight
                // Unit: Y value in 8 bits
                // Default value: 220
                // Data range: Integer, 0 ~ 255
                // Constraints: N/A.
                // Effect: The higher i4HdrHistP0, the fewer histogram bins are taken into partial consideration
                //
                // Variable name: i4HdrHistP1
                // Face detection bright side histogram bin threshold to full weight
                // Unit: Y value in 8 bits
                // Default value: 245
                // Data range: Integer, 0 ~ 255
                // Constraints: N/A.
                // Effect: The higher i4HdrHistP1, the fewer histogram bins are taken into fully consideration
                //
                // Variable name: i4HdrHistW0
                // Face detection bright side lower pixel weight
                // Default value: 0
                // Data range: Integer, 0 < i4HdrHistW0 <i4HdrHistW1
                // Constraints: N/A.
                // Effect: The higher i4HdrHistW0, bins between (i4HdrHistP0, i4HdrHistP1) will get higher partial weight
                //
                // Variable name: i4HdrHistW1
                // Face detection bright side higher pixel weight
                // Default value: 300
                // Data range: Integer, i4HdrHistW0 <i4HdrHistW1
                // Constraints: N/A.
                // Effect: The higher i4HdrHistW1, bins after i4HdrHistP1 will get higher fully weight
                /**************************************************/
                {               
                    // rHdrFDBrightWtWin
                    MINT32  i4HdrHistP0;
                    MINT32  i4HdrHistP1;
                    MINT32  i4HdrHistW0;
                    MINT32  i4HdrHistW1;
                },

                /**************************************************/
                // Variable name: i4HdrContrastPercentH
                // Bright side accumulated percentage for calculating contrast EV difference
                // Unit: 10*%
                // Default value: 60
                // Data range: Integer, 0 ~ 1000
                // Constraints: N/A.
                // Effect: The higher i4ContrastHistRatioH, more % of histogram will be accumulated from bright side
                //
                // Variable name: i4HdrContrastPercentL
                // Dark side accumulated percentage for calculating contrast EV difference
                // Unit: 10*%
                // Default value: 300
                // Data range: Integer, 0 ~ 1000
                // Constraints: N/A.
                // Effect: The higher i4ContrastHistRatioL, more % of histogram will be accumulated from dark side
                //
                // Variable name: i4HdrNightEVDiffPercentH
                // Bright side accumulated percentage for calculating night scene EV difference
                // Unit: 10*%
                // Default value: 50 or 30
                // Data range: Integer, 0 ~ 1000
                // Constraints: N/A.
                // Effect: The higher the i4HdrNightEVDiffPercentH, more % of histogram will be accumulated from bright side
                //
                // Variable name: i4HdrNightEVDiffPercentL
                // Dark side accumulated percentage for calculating night scene EV difference
                // Unit: 10*%
                // Default value: 300
                // Data range: Integer, 0 ~ 1000
                // Constraints: N/A.
                // Effect: The higher i4HdrNightEVDiffPercentL, more % of histogram will be accumulated from dark side
                //
                // Variable name: i4HdrNightDarkPercent
                // Night scene histogram Y %
                // It is used to calculate i4NightHistProb
                // Unit: 10*%
                // Default value: 500
                // Data range: Integer, 0 ~ 1000
                // Constraints: N/A.
                // Effect: It affects the calculation of histogram Y. The percentage depends on your purpose.
                /**************************************************/
                MINT32  i4HdrContrastPercentH;
                MINT32  i4HdrContrastPercentL;
                MINT32  i4HdrNightEVDiffPercentH;
                MINT32  i4HdrNightEVDiffPercentL;
                MINT32  i4HdrNightDarkPercent;

                /**************************************************/
                // Feature name: HDR night scene EV difference probability
                // The probability table interpolating for night scene probability by EV difference
                // Influence: night EVD probability, night scene probability, HDR ratio, HDR auto weight, HDR AE target Y/gain
                // rHdrNightEVDiffProb
                //
                // Variable name: rHdrNightEVDiffProb.i4X1
                // Min EV difference threshold to get min night scene probability (i4Y1)
                // Unit: EV*1000
                // Default value: 4800
                // Data range: Integer
                // Constraints: N/A.
                // Effect: The larger i4X1, larger EV difference zone will get min night scene probability
                //
                // Variable name: rHdrNightEVDiffProb.i4Y1
                // Min night scene probability according to i4X1
                // Unit: 1024*%/100
                // Default value: 0
                // Data range: Integer, 0 ~ 1024
                // Constraints: N/A.
                // Effect: If i4Y1 = 0, i4X1 would be the cutoff EV difference
                //         (EV difference < i4X1 will get zero probability)
                //         If i4Y1 > 0, we will get probability >= i4Y1
                //         (If i4Y1 > 0, we have certain faith of night scene for any EV difference input)
                //
                // Variable name: rHdrNightEVDiffProb.i4X2
                // Max EV difference threshold to get max night scene probability (i4Y2)
                // Unit: EV*1000
                // Default value: 6500
                // Data range: Integer
                // Constraints: N/A.
                // Effect: The larger i4X2, the smaller zone of EV difference get max night scene probability (i4Y2)
                //
                // Variable name: rHdrNightEVDiffProb.i4Y2
                // Max night scene probability according to i4X2
                // Unit: 1024*%/100
                // Default value: 1024
                // Data range: Integer, 0 ~ 1024
                // Constraints: N/A.
                // Effect: If i4Y2 = 1024, the EV difference >= i4X2 will get night scene probability of i4Y2
                /**************************************************/
                {               
                    // rHdrNightEVDiffProb
                    INT32 u4X1;
                    INT32 u4Y1;
                    INT32 u4X2;
                    INT32 u4Y2;
                },

                /**************************************************/
                // Feature name: HDR night scene histogram probability
                // The probability table for night scene probability by histogram avg Y
                // Influence: night histogram probability, night scene probability, HDR ratio, HDR auto weight, HDR AE target Y/gain
                // rHdrNightHistProb
                //
                // Variable name: rHdrNightHistProb.i4X1
                // Max histogram avg Y threshold to get max night scene probability (i4Y1)
                // Unit: Y value in 8 bits
                // Default value: 2
                // Data range: Integer, 0 ~ 255
                // Constraints: N/A.
                // Effect: The avg Y <= i4X1 will get max night scene probability (i4Y1)
                //
                // Variable name: rHdrNightHistProb.i4Y1
                // Max night scene probability according to i4X1
                // Unit: 1024*%/100
                // Default value: 1024
                // Data range: Integer, 0 ~ 1024
                // Constraints: N/A.
                // Effect: If i4X1 = 1024, the avg Y <= i4X1 will get 100% night scene probability
                //         If i4X1 < 1024, it means that we're not 100% sure for night scene, judging by avg Y
                //
                // Variable name: rHdrNightHistProb.i4X2
                // Min histogram avg Y threshold to get min night scene probability (i4Y2)
                // Unit: Y value in 8 bits
                // Default value: 10
                // Data range: Integer, 0 ~ 255
                // Constraints: N/A.
                // Effect: The higher i4X2, the higher avg Y we need to exclude the possibility of night scene
                //
                // Variable name: rHdrNightHistProb.i4Y2
                // Min night scene probability according to i4X2
                // Unit: 1024*%/100
                // Default value: 0
                // Data range: Integer, 0 ~ 1024
                // Constraints: N/A.
                // Effect: If i4Y2 = 0, then i4X2 is the cutoff avg Y to exclude the possibility of night scene
                /**************************************************/
                {   
                    // rHdrNightHistProb
                    INT32 u4X1;
                    INT32 u4Y1;
                    INT32 u4X2;
                    INT32 u4Y2;
                },

                /**************************************************/
                // Feature name: HDR night scene LV probability
                // The probability table for night scene probability by scene LV
                // Influence: night LV probability, night scene probability, HDR ratio, HDR auto weight, HDR AE target Y/gain
                //  rHdrNightLVProb
                // Variable name: rHdrNightLVProb.i4X1
                // Max scene LV threshold to get max night scene probability (i4Y1)
                // Unit: 10*LV
                // Default value: 50
                // Data range: Integer, 0 ~ 190
                // Constraints: N/A.
                // Effect: Scene LV <= i4X1 will get max night scene probability (i4Y1)
                //
                // Variable name: rHdrNightLVProb.i4Y1
                // Max night scene probability according to i4X1
                // Unit: 1024*%/100
                // Default value: 1024
                // Data range: Integer, 0 ~ 1024
                // Constraints: N/A.
                // Effect: If i4Y1 = 1024, scene LV <= i4X1 will get 100% night scene probability
                //         If i4Y1 < 1024, it means that we cannot 100% exclude the posibility of night scene
                //
                // Variable name: rHdrNightLVProb.i4X2
                // Min scene LV threshold to get min night scene probability (i4Y2)
                // Unit: 10*LV
                // Default value: 100
                // Data range: Integer, 0 ~ 190
                // Constraints: N/A.
                // Effect: The higher i4X2, higher scene LV is needed to exclude the possibility of night scene
                //
                // Variable name: rHdrNightLVProb.i4Y2
                // Min night scene probability according to i4X2
                // Unit: 1024*%/100
                // Default value: 0
                // Data range: Integer, 0 ~ 1024
                // Constraints: N/A.
                // Effect: If i4Y2 = 0, i4X2 is the cutoff scene LV to exclude the possibility of night scene
                /**************************************************/
                {
                    //rHdrNightLVProb
                    INT32 u4X1;
                    INT32 u4Y1;
                    INT32 u4X2;
                    INT32 u4Y2;
                }
            },

            /**************************************************/
            // Feature name: HDR geometry information (for HDR detector)
            // Calculating for HDR detector by geometry information
            // HDR detector will turn HDR ON if the HDR probability results of histogram, geometry, LV exceed threshold
            // rHdrGeometryInfo
            /**************************************************/
            {
                /**************************************************/
                // Feature name: geometry center over exposure probability
                // HDR scene share the same property as center over exposure
                // rGeometryCOEProp
                /**************************************************/
                {
                    /**************************************************/
                    // Variable name: bGeometryCOEEnable
                    // A switch for HDR detector by geometry COE
                    // Default value: TRUE.
                    // Data range: TRUE or FALSE.
                    // Constraints: N/A.
                    // Effect: Set TRUE to enable geometry COE
                    //
                    // Variable name: i4COEWeight
                    // Weight to control the importance of COE in detecting HDR scene
                    // Default value: 1024
                    // Data range: Integer
                    // Constraints: N/A.
                    // Effect: If COE is important to detect the HDR scene, set i4COEWeight >= 1024.
                    /**************************************************/
                    MBOOL   bGeometryCOEEnable;
                    MINT32  i4COEWeight;         // x1 = 1024

                    /**************************************************/
                    // Feature name: HDR center over-exposure outer ratio
                    // The outer geometry average information of AE statistics for HDR detector
                    // Influence: COE outer probability, COE outer weight probability
                    // rHdrCOEOuterRatio
                    //
                    // Variable name: rHdrCOEOuterRatio.i4X1
                    // Max outer average threshold to get max COE probability (i4Y1)
                    // Unit: Y value in 8 bits
                    // Default value: 23
                    // Data range: Integer
                    // Constraints: N/A.
                    // Effect: The outer average <= i4X1 will get max COE probability (i4Y1)
                    //
                    // Variable name: rHdrCOEOuterRatio.i4Y1
                    // Max COE probability according to i4X1
                    // Unit: 1024*%/100
                    // Default value: 1024
                    // Data range: Integer, 0 ~ 1024
                    // Constraints: N/A.
                    // Effect: If i4Y1 = 1024, the outer average <= i4X1 will get 100% COE probability
                    //         If i4Y1 <= 1024, it means that we're not 100% sure for COE, judging by outer average
                    //
                    // Variable name: rHdrCOEOuterRatio.i4X2
                    // Min outer average threshold to get min COE probability (i4Y2)
                    // Unit: Y value in 8 bits
                    // Default value: 47
                    // Data range: Integer
                    // Constraints: N/A.
                    // Effect: The higher i4X2, higher outer average is needed to exclude the possibility of COE
                    //
                    // Variable name: rHdrCOEOuterRatio.i4Y2
                    // Min COE probability according to i4X2
                    // Unit: 1024*%/100
                    // Default value: 0
                    // Data range: Integer, 0 ~ 1024
                    // Constraints: N/A.
                    // Effect: If i4Y2 = 0, i4X2 is the cutoff outer average to exclude the possibility of COE
                    /**************************************************/
                    {           
                        // rHdrCOEOuterRatio
                        INT32 u4X1;
                        INT32 u4Y1;
                        INT32 u4X2;
                        INT32 u4Y2;
                    },

                    /**************************************************/
                    // Feature name: HDR center over-exposure difference ratio
                    // The outer/inner geometry EV difference of AE statistics for HDR detector
                    // Influence: COE difference probability, COE difference weight probability, HDR on/off
                    // rHdrCOEDiffRatio
                    //
                    // Variable name: rHdrCOEOuterRatio.i4X1
                    // Max outer/inner difference threshold to get min COE probability (i4Y1)
                    // Unit: EV*1000
                    // Default value: 1900
                    // Data range: Integer
                    // Constraints: N/A.
                    // Effect: The larger i4X1, larger outer/inner geometry EV difference zone will get min COE probability (i4Y1)
                    //
                    // Variable name: rHdrCOEOuterRatio.i4Y1
                    // Min COE probability according to i4X1
                    // Unit: 1024*%/100
                    // Default value: 0
                    // Data range: Integer, 0 ~ 1024
                    // Constraints: N/A.
                    // Effect: If i4Y1 = 0, i4X1 would be the cutoff outer/inner geometry EV difference
                    //         (EV difference < i4X1 will get zero probability)
                    //         If i4Y1 > 0, we will get probability >= i4Y1
                    //         (If i4Y1 > 0, we have certain faith of COE for any outer/inner geometry input)
                    //
                    // Variable name: rHdrCOEOuterRatio.i4X2
                    // Min outer/inner difference threshold to get max COE probability (i4Y2)
                    // Unit: EV*1000
                    // Default value: 2400
                    // Data range: Integer
                    // Constraints: N/A.
                    // Effect: The larger i4X2, the smaller zone of outer/inner geometry EV difference get max COE probability (i4Y2)
                    //
                    // Variable name: rHdrCOEOuterRatio.i4Y2
                    // Max COE probability according to i4X2
                    // Unit: 1024*%/100
                    // Default value: 1024
                    // Data range: Integer, 0 ~ 1024
                    // Constraints: N/A.
                    // Effect: If i4Y2 = 1024, the the outer/inner EV difference >= i4X2 will get COE probability of i4Y2
                    /**************************************************/
                    {           
                        // rHdrCOEDiffRatio
                        INT32 u4X1;
                        INT32 u4Y1;
                        INT32 u4X2;
                        INT32 u4Y2;
                    }
                 },

                /**************************************************/
                // Feature name: HDR anti-back-light(ABL) probability
                // HDR scene share the same property as back-light
                // rGeometryABLProp
                /**************************************************/
                {
                    /**************************************************/
                    // Variable name: bGeometryABLEnable
                    // A switch for HDR detector by geometry ABL
                    // Default value: TRUE.
                    // Data range: TRUE or FALSE.
                    // Constraints: N/A.
                    // Effect: Set TRUE to enable geometry ABL
                    //
                    // Variable name: i4ABLWeight
                    // Weight to control the importance of ABL in detecting HDR scene
                    // Default value: 1024
                    // Data range: Integer
                    // Constraints: N/A.
                    // Effect: If ABL is important to detect the HDR scene, set i4ABLWeight >= 1024.
                    /**************************************************/
                    BOOL     bGeometryABLEnable;
                    MINT32   i4ABLWeight;        // x1 = 1024

                    /**************************************************/
                    // Feature name: HDR center bright difference ratio
                    // The ABL target probability table when center is brighter than C/U type
                    // Influence: ABL difference probability, HDR on/off
                    // rCenterBrightDiffRatio
                    //
                    // Variable name: rCenterBrightDiffRatio.i4X1
                    // Max ABL EV difference threshold to get min ABL probability (i4Y1)
                    // Unit: EV*1000
                    // Default value: 3150
                    // Data range: Integer
                    // Constraints: N/A.
                    // Effect: The larger i4X1, larger ABL EV difference zone will get min ABL probability (i4Y1)
                    //
                    // Variable name: rCenterBrightDiffRatio.i4Y1
                    // Min ABL probability according to i4X1
                    // Unit: 1024*%/100
                    // Default value: 0
                    // Data range: Integer, 0 ~ 1024
                    // Constraints: N/A.
                    // Effect: If i4Y1 = 0, i4X1 would be the cutoff ABL EV difference
                    //         (EV difference < i4X1 will get zero ABL probability)
                    //         If i4Y1 > 0, we will get ABL probability >= i4Y1
                    //         (If i4Y1 > 0, we have certain faith of ABL for any ABL EV difference input)
                    //
                    // Variable name: rCenterBrightDiffRatio.i4X2
                    // Min ABL EV difference threshold to get max ABL probability (i4Y2)
                    // Unit: EV*1000
                    // Default value: 5000
                    // Data range: Integer
                    // Constraints: N/A.
                    // Effect: The larger i4X2, the smaller zone of ABL EV difference get max ABL probability (i4Y2)
                    //
                    // Variable name: rCenterBrightDiffRatio.i4Y2
                    // Max ABL probability according to i4X2
                    // Unit: 1024*%/100
                    // Default value: 1024
                    // Data range: Integer, 0 ~ 1024
                    // Constraints: N/A.
                    // Effect: If i4Y2 = 1024, the the ABL EV difference >= i4X2 will get ABL probability of i4Y2
                    /**************************************************/
                    {           
                        // rCenterBrightDiffRatio
                        INT32 u4X1;
                        INT32 u4Y1;
                        INT32 u4X2;
                        INT32 u4Y2;
                    },

                    /**************************************************/
                    // Feature name: HDR center dark difference ratio
                    // The ABL target probability table when center is darker than C/U type
                    // Influence: ABL difference probability, HDR on/off
                    // rCenterDarkDiffRatio
                    // Variable name: rCenterDarkDiffRatio.i4X1
                    // Max ABL EV difference threshold to get min ABL probability (i4Y1)
                    // Unit: EV*1000
                    // Default value: 3150
                    // Data range: Integer
                    // Constraints: N/A.
                    // Effect: The larger i4X1, larger ABL EV difference zone will get min ABL probability (i4Y1)
                    //
                    // Variable name: rCenterDarkDiffRatio.i4Y1
                    // Min ABL probability according to i4X1
                    // Unit: 1024*%/100
                    // Default value: 0
                    // Data range: Integer, 0 ~ 1024
                    // Constraints: N/A.
                    // Effect: If i4Y1 = 0, i4X1 would be the cutoff ABL EV difference
                    //         (EV difference < i4X1 will get zero ABL probability)
                    //         If i4Y1 > 0, we will get ABL probability >= i4Y1
                    //         (If i4Y1 > 0, we have certain faith of ABL for any ABL EV difference input)
                    //
                    // Variable name: rCenterDarkDiffRatio.i4X2
                    // Min ABL EV difference threshold to get max ABL probability (i4Y2)
                    // Unit: EV*1000
                    // Default value: 5000
                    // Data range: Integer
                    // Constraints: N/A.
                    // Effect: The larger i4X2, the smaller zone of ABL EV difference get max ABL probability (i4Y2)
                    //
                    // Variable name: rCenterDarkDiffRatio.i4Y2
                    // Max ABL probability according to i4X2
                    // Unit: 1024*%/100
                    // Default value: 1024
                    // Data range: Integer, 0 ~ 1024
                    // Constraints: N/A.
                    // Effect: If i4Y2 = 1024, the the ABL EV difference >= i4X2 will get ABL probability of i4Y2
                    /**************************************************/
                    {           
                        // rCenterDarkDiffRatio
                        INT32 u4X1;
                        INT32 u4Y1;
                        INT32 u4X2;
                        INT32 u4Y2;
                    }
                }
            },
            /**************************************************/
            // Feature name: HDR LV Information (for HDR detector)
            // Calculating LV information for HDR detector
            // Judge HDR scene by LV information, it helps to exclude the probability of night scene
            // Influence: LV probability, HDR on/off
            // rHdrLVInfo
            /**************************************************/
            {
                /**************************************************/
                // Variable name: bLVDetectEnable
                // A switch to use LV to detect HDR scene
                // Default value: TRUE.
                // Data range: TRUE or FALSE.
                // Constraints: N/A.
                // Effect: Set TRUE to enable HDR LV analysis
                //
                // Variable name: i4LVProbTbl
                // LV table for detecting HDR scene
                // Unit: %
                // Default value: { 0, 0, 25, 25, 25, 50, 75, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100}
                // Data range: Integer, 0 ~ 100
                // Constraints: N/A.
                // Effect: Set the probability of HDR scene according to LV information
                /**************************************************/
                
                BOOL    bLVDetectEnable;
                MINT32  i4LVProbTbl[HDR_AE_LV_TBL_NUM];
            }
        },

        /**************************************************/
        // Feature name: HDR auto-enhance
        // Calculating information for HDR ratio
        // rHdrAutoEnhance
        /**************************************************/
        {
            /**************************************************/
            // Variable name: bAutoEnhanceEnable
            // A switch to calculate HDR ratio information
            // Default value: TRUE.
            // Data range: TRUE or FALSE.
            // Constraints: N/A.
            // Effect: Set TRUE to enable HDR BV analysis
            //
            // Variable name: i4RMGk
            // Control the height of turning point to LE/SE curve
            // Default value: 4095
            // Data range: Integer, 0 ~ 4095
            // Constraints: N/A.
            // Effect: Set i4RMGk higher(lower) to make LE longer(shorter)
            //
            // Variable name: i4RMGtRatio
            // Set the percentage of current Y for calculating RMGt
            // Unit: 10*%
            // Default value: 40
            // Data range: Integer, 0 ~ 1000
            // Constraints: N/A.
            // Effect: The higher i4RMGtRatio, more percentage of histogram will be accumulated in current Y
            /**************************************************/
            BOOL    bAutoEnhanceEnable;
            MINT32  i4RMGk;
            MINT32  i4RMGtRatio;

            /**************************************************/
            // Feature name: RMGt
            // Interpolation table for RMGt
            // Influence: the turning point between LE/SE curve
            // If current Y is large(small), use data of SE(LE) more
            // rRMGt
            //
            // Variable name: rRMGt.i4X1
            // Max current Y threshold to get max RMGt i4Y1
            // Unit: Y value in 8 bits
            // Default value: 160
            // Data range: Integer, 0 ~ 255
            // Constraints: N/A.
            // Effect: The larger i4X1, larger current Y zone will get max RMGt setting (i4Y1)
            //         The current Y lower than i4Y1 will get longer LE curve.
            //
            // Variable name: rRMGt.i4Y1
            // Max RMGt setting, controls the horizontal ratio of the result from RMGk.
            // Unit: Y value in 10 bits
            // Default value: 512
            // Data range: Integer, 0 ~ 1023
            // Constraints: N/A.
            // Effect: The larger i4Y1, the longer LE curve we will get
            //
            // Variable name: rRMGt.i4X2
            // Min current Y to get min RMGt i4Y2
            // Unit: Y value in 8 bits
            // Default value: 220
            // Data range: Integer, 0 ~ 255
            // Constraints: N/A.
            // Effect: The larger i4X2, smaller current Y zone will get min RMGt setting (i4Y2)
            //         The current Y higher than i4Y1 will get shorter LE curve.
            //
            // Variable name: rRMGt.i4Y2
            // Max RMGt setting, controls the horizontal ratio of the result from RMGk.
            // Unit: Y value in 10 bits
            // Default value: 384
            // Data range: Integer, 0 ~ 1023
            // Constraints: N/A.
            // Effect: The larger i4Y2, the longer LE curve we will gets
            /**************************************************/
            {                   
                // rRMGt
                INT32 u4X1;
                INT32 u4Y1;
                INT32 u4X2;
                INT32 u4Y2;
            },

            //Not used
            /**************************************************/
            MINT32                  i4SupportHdrNum;
            MINT32                  i4AutoEnhanceProb;
            MINT32                  i4HdrWeight;
            /**************************************************/

            // rAutoBright
            {
                /**************************************************/
                // Variable name: i4LVRatio50
                // Ratio interpolation table by scene LV, for 50 Hz
                // Unit: 100*LE/SE
                // Default value: None
                // Data range: Integer, 100 ~ 800
                // Constraints: N/A.
                // Effect: Set different HDR ratio for different scene LV
                //
                // Variable name: i4LVRatio60
                // Ratio interpolation table by scene LV, for 60 Hz
                // Unit: 100*LE/SE
                // Default value: None
                // Data range: Integer, 100 ~ 800
                // Constraints: N/A.
                // Effect: Set different HDR ratio for different scene LV
                /**************************************************/
                MINT32  i4LVRatio50[HDR_AE_LV_TBL_NUM];
                MINT32  i4LVRatio60[HDR_AE_LV_TBL_NUM];

                 /**************************************************/
                // Feature name: rContrastRatio
                // HDR ratio interpolation table by HDR contrast EV difference
                // Influence: auto contrast ratio, HDR ratio
                // rContrastRatio
                //
                // Variable name: rContrastRatio.i4X1
                // Max contrast EVD threshold to get min HDR ratio i4Y1
                // Unit: EV*1000
                // Default value: 3500
                // Data range: Integer, i4X1 > 0
                // Constraints: N/A.
                // Effect: The larger i4X1, larger contrast EVD zone will get min HDR ratio (i4Y1)
                //
                // Variable name: rContrastRatio.i4Y1
                // Min HDR ratio according to i4X1
                // Unit: 100*LE/SE
                // Default value: 100
                // Data range: Integer, 100 ~ 800
                // Constraints: N/A.
                // Effect: The larger i4Y1, the larger HDR ratio we will get
                //
                // Variable name: rContrastRatio.i4X2
                // Min contrast EVD to get max HDR ratio i4Y2
                // Unit: EV*1000
                // Default value: 4500
                // Data range: Integer, i4X2 > 0
                // Constraints: N/A.
                // Effect: The larger i4X2, smaller contrast EVD zone will get max HDR ratio (i4Y2)
                //
                // Variable name: rContrastRatio.i4Y2
                // Max HDR ratio according to i4X2
                // Unit: 100*LE/SE
                // Default value: 200
                // Data range: Integer, 100 ~ 800
                // Constraints: N/A.
                // Effect: The larger i4Y2, the larger HDR ratio we will get
                /**************************************************/
                {                 
                    // rContrastRatio
                    INT32 u4X1;
                    INT32 u4Y1;
                    INT32 u4X2;
                    INT32 u4Y2;
                },

                /**************************************************/
                // Feature name: rBrightRatio
                // HDR ratio interpolation table by HDR bright side histogram information
                // Influence: auto bright probability, HDR ratio
                //rBrightRatio
                //
                // Variable name: rBrightRatio.i4X1
                // Max bright side histogram threshold to get HDR ratio i4Y1
                // Unit: weighting average pixel count
                // Default value: 600
                // Data range: Integer, i4X1 > 0
                // Constraints: N/A.
                // Effect: The larger i4X1, larger bright side histogram zone will get min HDR ratio (i4Y1)
                //
                // Variable name: rBrightRatio.i4Y1
                // Min HDR ratio according to i4X1
                // Unit: 100*LE/SE
                // Default value: 200 or 400
                // Data range: Integer, 100 ~ 800
                // Constraints: N/A.
                // Effect: The larger i4Y1, the larger HDR ratio we will get
                //
                // Variable name: rBrightRatio.i4X2
                // Min bright side histogram to get max HDR ratio i4Y2
                // Unit: weighting average pixel count
                // Default value: 1100
                // Data range: Integer, i4X2 > 0
                // Constraints: N/A.
                // Effect: The larger i4X2, smaller bright side histogram zone will get max HDR ratio (i4Y2)
                //
                // Variable name: rBrightRatio.i4Y2
                // Max HDR ratio according to i4X2
                // Unit: 100*LE/SE
                // Default value: 200 or 400
                // Data range: Integer, 100 ~ 800
                // Constraints: N/A.
                // Effect: The larger i4Y2, the larger HDR ratio we will get
                /**************************************************/
                {               
                    // rBrightProbRatio
                    INT32 u4X1;
                    INT32 u4Y1;
                    INT32 u4X2;
                    INT32 u4Y2;
                },

                /**************************************************/
                // Feature name: rNightProbRatio
                // HDR ratio interpolation table by night scene probability
                // Influence: auto night probability, HDR ratio
                // rNightProbRatio
                // Variable name: rNightProbRatio.i4X1
                // Max night scene probability threthold to get max HDR ratio i4Y1
                // Unit: 1024*%/100
                // Default value: 0
                // Data range: Integer, 0 ~ 1024
                // Constraints: N/A.
                // Effect: The larger i4X1, larger night scene probability zone will get max HDR ratio (i4Y1)
                //
                // Variable name: rNightProbRatio.i4Y1
                // Max HDR ratio according to i4X1
                // Unit: 100*LE/SE
                // Default value: none
                // Data range: Integer, 100 ~ 800
                // Constraints: N/A.
                // Effect: The larger i4Y1, the larger HDR ratio we will get
                //
                // Variable name: rNightProbRatio.i4X2
                // Min night scene probability to get max HDR ratio i4Y2
                // Unit: 1024*%/100
                // Default value: 512
                // Data range: Integer, 0 ~ 1024
                // Constraints: N/A.
                // Effect: The larger i4X2, smaller night scene probability zone will get min HDR ratio (i4Y2)
                //
                // Variable name: rNightProbRatio.i4Y2
                // Min HDR ratio according to i4X2
                // Unit: 100*LE/SE
                // Default value: none
                // Data range: Integer, 100 ~ 800
                // Constraints: N/A.
                // Effect: The larger i4Y2, the larger HDR ratio we will get
                /**************************************************/
                {               
                    // rNightProbRatio
                    INT32 u4X1;
                    INT32 u4Y1;
                    INT32 u4X2;
                    INT32 u4Y2;
                },

                /**************************************************/
                // Feature name: motion information
                // The motion corresponding information including gyro, accelerator,
                // Influence: HDR ratio, HDR on/off, on/off smoothness
                // rGGyroSensor
                /**************************************************/
                {
                    /**************************************************/
                    // Feature name: rAcceProb
                    // Acceleration probability interpolation table by accelerator information
                    // Influence: HDR ratio, motion on/off
                    // rAcceProb
                    //
                    // Variable name: rAcceProb.i4X1
                    // Max acceleration threthold to get min acceleration probability i4Y1
                    // Default value: none
                    // Data range: Integer, i4X1 > 0
                    // Constraints: N/A.
                    // Effect: The larger i4X1, larger acceleration zone will get min acceleration probability (i4Y1)
                    //
                    // Variable name: rAcceProb.i4Y1
                    // Min acceleration probability according to i4X1
                    // Unit: 1024*%/100
                    // Default value: 0
                    // Data range: Integer, 0 ~ 1024
                    // Constraints: N/A.
                    // Effect: If i4Y1 = 0, i4X1 is the cutoff acceleration to get min acceleration probability
                    //
                    // Variable name: rAcceProb.i4X2
                    // Min acceleration to get max acceleration probability i4Y2
                    // Default value: none
                    // Data range: Integer, i4X2 > 0
                    // Constraints: N/A.
                    // Effect: The larger i4X2, smaller acceleration zone will get max acceleration probability (i4Y2)
                    //
                    // Variable name: rAcceProb.i4Y2
                    // Max acceleration probability according to i4X2
                    // Unit: 1024*%/100
                    // Default value: 1024
                    // Data range: Integer, 0 ~ 1024
                    // Constraints: N/A.
                    // Effect: If i4Y2 = 1024, the acceleration > i4X2 will get 100% acceleration probability
                    /**************************************************/
                    {               
                        // rAcceProb
                        INT32 u4X1;
                        INT32 u4Y1;
                        INT32 u4X2;
                        INT32 u4Y2;
                    },

                    /**************************************************/
                    // Feature name: rGyroProb
                    // Motion probability interpolation table by gyro sensor information
                    // Influence: HDR ratio, motion on/off
                    // rGyroProb
                    //
                    // Variable name: rGyroProb.i4X1
                    // Max motion threthold to get min motion probability i4Y1
                    // Default value: none
                    // Data range: Integer, i4X1 > 0
                    // Constraints: N/A.
                    // Effect: The larger i4X1, larger motion zone will get min motion probability (i4Y1)
                    //
                    // Variable name: rGyroProb.i4Y1
                    // Min motion probability according to i4X1
                    // Unit: 1024*%/100
                    // Default value: 0
                    // Data range: Integer, 0 ~ 1024
                    // Constraints: N/A.
                    // Effect: If i4Y1 = 0, i4X1 is the cutoff motion to get min motion probability
                    //
                    // Variable name: rGyroProb.i4X2
                    // Min motion to get max motion probability i4Y2
                    // Default value: none
                    // Data range: Integer, i4X2 > 0
                    // Constraints: N/A.
                    // Effect: The larger i4X2, smaller motion zone will get max motion probability (i4Y2)
                    //
                    // Variable name: rGyroProb.i4Y2
                    // Max motion probability according to i4X2
                    // Unit: 1024*%/100
                    // Default value: 1024
                    // Data range: Integer, 0 ~ 1024
                    // Constraints: N/A.
                    // Effect: If i4Y2 = 1024, the motion > i4X2 will get 100% motion probability
                    /**************************************************/
                    {               
                        // rGyroProb
                        INT32 u4X1;
                        INT32 u4Y1;
                        INT32 u4X2;
                        INT32 u4Y2;
                    },

                    /**************************************************/
                    // Feature name: rMotionRatio
                    // HDR ratio interpolation table by motion (gyro + acce) probability information
                    // Influence: HDR ratio
                    // rMotionRatio
                    //
                    // Variable name: rMotionRatio.i4X1
                    // Max motion probability threthold to get min HDR ratio i4Y1
                    // Unit: 2048*%/100
                    // Default value: 512
                    // Data range: Integer, 0 ~ 2048
                    // Constraints: N/A.
                    // Effect: The larger i4X1, larger motion probability zone will get max HDR ratio (i4Y1)
                    //
                    // Variable name: rMotionRatio.i4Y1
                    // Max HDR ratio according to i4X1
                    // Unit: 100*LE/SE
                    // Default value: 400
                    // Data range: Integer, 100 ~ 800
                    // Constraints: N/A.
                    // Effect: The larger i4Y1, the larger HDR ratio we will get
                    //
                    // Variable name: rMotionRatio.i4X2
                    // Min motion probability to get max HDR ratio i4Y2
                    // Unit: 2048*%/100
                    // Default value: 960
                    // Data range: Integer, i4X2 > 0
                    // Constraints: N/A.
                    // Effect: The larger i4X2, smaller motion probability zone will get min HDR ratio (i4Y2)
                    //
                    // Variable name: rMotionRatio.i4Y2
                    // Min HDR ratio according to i4X2
                    // Unit: 100*LE/SE
                    // Default value: 100
                    // Data range: Integer, 100 ~ 800
                    // Constraints: N/A.
                    // Effect: The larger i4Y1, the larger HDR ratio we will get
                    /**************************************************/
                    {               
                        // rMotionRatio
                        INT32 u4X1;
                        INT32 u4Y1;
                        INT32 u4X2;
                        INT32 u4Y2;
                    },

                    /**************************************************/
                    // Variable name: i4MotionOnThr
                    // Threshold to determine motion on/off
                    // Unit: 1024*%/100
                    // Default value: 512 or 768
                    // Data range: Integer, i4MotionOnThr > 0
                    // Constraints: N/A.
                    // Effect: The larger i4MotionOnThr, you need higher motion probability to set motion detector on
                    //
                    // Variable name: i4MotionOnCntThr
                    // Counting threshold to update motion on/off information
                    // Unit: frame count
                    // Default value: 2 or 5
                    // Data range: Integer, i4MotionOnCntThr > 0
                    // Constraints: N/A.
                    // Effect: The larger i4MotionOnCntThr, you need count more to update motion on/off
                    /**************************************************/
                    MINT32  i4MotionOnThr;
                    MINT32  i4MotionOnCntThr;
                }
            },

            /**************************************************/
            // Feature name: rAutoFlicker
            // Parameter setting to automatically avoid flicker
            // rAutoFlicker
            /**************************************************/
            {
                /**************************************************/
                // Variable name: i4Flkr1LVThr
                // LV threshold for deflicker enable
                // Unit: LV*10
                // Default value: {130,130}
                // Data range: Integer, 0 ~ 180
                // Constraints: N/A.
                // Effect: The higher i4Flkr1LVThr, the higher scene LV needed to enable deflicker
                //
                // Variable name: i4MinRatioAntiFlk
                // The min acceptable ratio for anti-flicker
                // Unit: 100*LE/SE
                // Default value: 200 or 800
                // Data range: Integer, 100 ~ 800
                // Constraints: N/A.
                // Effect: The ratio lower i4MinRatioAntiFlk than could get flickered results
                /**************************************************/
                MINT32 i4Flkr1LVThr[2];         // [0]: 50 Hz,  [1]: 60 Hz
                MINT32 i4MinRatioAntiFlk;       // The min. acceptable ratio for anti-flicker. 200: 2x ratio

                //Not used
                /**************************************************/
                MINT32 i4MaxExp[2]; // i4MaxExp[0]: 50Hz  i4MaxExp[1]: 60Hz
                MINT32 i4MinExp[2]; // i4MinExp[0]: 50Hz  i4MinExp[1]: 60Hz    
                /**************************************************/


                /**************************************************/
                // Feature name: rIsoThr
                // HDR ratio interpolation table by ISO information
                // Influence: HDR ratio
                // rIsoThr
                //
                // Variable name: rIsoThr.i4X1
                // Max ISO threshold to get max HDR ratio i4Y1
                // Unit: 1024*gain
                // Default value: none
                // Data range: Integer, i4X1 > 0
                // Constraints: N/A.
                // Effect: The larger i4X1, larger ISO zone will get max HDR ratio (i4Y1)
                //
                // Variable name: rIsoThr.i4Y1
                // Max HDR ratio according to i4X1
                // Unit: LE/SE
                // Default value: none
                // Data range: Integer, 100 ~ 800
                // Constraints: N/A.
                // Effect: The larger i4Y1, the larger HDR ratio we will get
                //
                // Variable name: rIsoThr.i4X2
                // Min ISO to get min HDR ratio i4Y2
                // Unit: 1024*gain
                // Default value: none
                // Data range: Integer, i4X2 > 0
                // Constraints: N/A.
                // Effect: The larger i4X2, smaller ISO zone will get min HDR ratio (i4Y2)
                //
                // Variable name: rIsoThr.i4Y2
                // Min HDR ratio according to i4X2
                // Unit: LE/SE
                // Default value: none
                // Data range: Integer, 100 ~ 800
                // Constraints: N/A.
                // Effect: The larger i4Y2, the larger HDR ratio we will get
                /**************************************************/
                {               
                    // rIsoThr
                    INT32 u4X1;
                    INT32 u4Y1;
                    INT32 u4X2;
                    INT32 u4Y2;
                },
            },

            /**************************************************/
            // Feature name: rAutoSmooth
            // HDR auto smooth (HDR on/off, motion on/off, HDR ratio smooth) information
            // rAutoSmooth
            /**************************************************/
            {
                /**************************************************/
                // Variable name: bHdrWaitAEStable
                // A switch to determine wait for AE stable or not
                // Default value: TRUE.
                // Data range: TRUE or FALSE.
                // Constraints: N/A.
                // Effect: Set TRUE to enable wait
                //
                // Variable name: i4HdrInfoCounterThr
                // Threshold to update HDR on/off information
                // Unit: frame count
                // Default value: 6
                // Data range: Integer, i4HdrInfoCounterThr > 0
                // Constraints: N/A.
                // Effect: HDR on/off counter larger than i4HdrInfoCounterThr can update the on/off result
                /**************************************************/
                BOOL    bHdrWaitAEStable;
                MINT32  i4HdrInfoCounterThr;

                //Not used
                /**************************************************/
                BOOL    bRatioSmoothEnable;  // bRatioSmoothEnable TRUE for platform / FALSE for simulation
                /**************************************************/

                /**************************************************/
                // Variable name: i4RatioSmoothThr
                // Threshold to update HDR ratio smooth information
                // Unit: frame count
                // Default value: none
                // Data range: Integer, i4RatioSmoothThr > 0
                // Constraints: N/A.
                // Effect: HDR ratio smooth counter larger than i4RatioSmoothThr can update the smoothed HDR ratio result
                //
                // Variable name: i4RoughRatioUnit
                // Threshold to check if difference of current ratio and current stable ratio is large enough
                // Unit: 100*LE/SE
                // Default value: none
                // Data range: Integer, i4RoughRatioUnit > 0
                // Constraints: N/A.
                // Effect: Difference of current ratio and current stable ratio larger than i4RoughRatioUnit check for close results in incoming frames
                //
                // Variable name: i4FinerRatioUnit
                // Threshold to check if difference of current/previous ratio is small enough
                // Unit: 100*LE/SE
                // Default value: none
                // Data range: Integer, i4FinerRatioUnit > 0
                // Constraints: N/A.
                // Effect: Difference of current/previous HDR ratio > i4FinerRatioUnit start to count
                /**************************************************/
                MINT32  i4RatioSmoothThr[2];    //  [0]:normal, [1]:motion
                MINT32  i4RoughRatioUnit[2];    //  [0]:normal, [1]:motion
                MINT32  i4FinerRatioUnit[2];    //  [0]:normal, [1]:motion
                //Not used
                /**************************************************/
                MINT32  i4RMGtUnit[2];          //  [0]:normal, [1]:motion
                /**************************************************/
            },
            {                   
                // rAutoDark
                // TBD
            },

            //Not used
            /**************************************************/
            {                   
                // rAutoTuning
                MINT32  i4RmmExpoDiffThr;
                MINT32  i4LscRatio;      
            }
            /**************************************************/
        },

        /**************************************************/
        // Feature name: rHdrAETarget
        // HDR AE target parameter setting
        // rHdrAETarget
        /**************************************************/
        {
            /**************************************************/
            // Variable name: i4DefTarget
            // Default AE target
            // Unit: Y value in 8 bits
            // Default value: 47
            // Data range: Integer, 0 ~ 255
            // Constraints: N/A.
            // Effect: A reference of AE target, set higher to make AE target higher
            //
            // Variable name: i4DefWeight
            // Weight of default target, mixing with normal AE target
            // Default value: 47
            // Data range: Integer, 0 ~ 1024
            // Constraints: N/A.
            // Effect: Set i4DefWeight higher to make the proportion of default AE target higher
            /**************************************************/
            MINT32  i4DefTarget;
            MINT32  i4DefWeight;

            /**************************************************/
            // Feature name: rAutoEVWeight
            // HDR auto EV weight interpolation table
            // Influence: auto EV weight, HDR auto weight
            // rAutoEVWeight
            //
            // Variable name: rAutoEVWeight.i4X1
            // Max contrast EVD threshold to get min auto EV weight (i4Y1)
            // Unit: EV*1000
            // Default value: 4000 or 3750
            // Data range: Integer, i4X1 > 0
            // Constraints: N/A.
            // Effect: The larger i4X1, larger contrast EVD zone will get min auto EV weight (i4Y1)
            //
            // Variable name: rAutoEVWeight.i4Y1
            // Min auto EV weight according to i4X1
            // Unit: 1024*%/100
            // Default value: 256
            // Data range: Integer, 0 ~ 1024
            // Constraints: N/A.
            // Effect: We will at least get i4Y1 weight
            //
            // Variable name: rAutoEVWeight.i4X2
            // Min contrast EVD threshold to get max auto EV weight i4Y2
            // Unit: EV*1000
            // Default value: 4500 or 5000
            // Data range: Integer, i4X2 > 0
            // Constraints: N/A.
            // Effect: The larger i4X2, smaller contrast EVD zone will get max auto EV weight (i4Y2)
            //
            // Variable name: rAutoEVWeight.i4Y2
            // Max auto EV weight according to i4X2
            // Unit: 1024*%/100
            // Default value:  512 or 768
            // Data range: Integer, 0 ~ 1024
            // Constraints: N/A.
            // Effect: The contrast EVD larger than i4X2 will get auto EV weight of i4Y2
            /**************************************************/
            {                   
                // rAutoEVWeight
                INT32 u4X1;
                INT32 u4Y1;
                INT32 u4X2;
                INT32 u4Y2;
            },

            /**************************************************/
            // Feature name: rAutoBrightWeight
            // HDR auto bright weight interpolation table
            // Influence: auto bright weight, auto night weight, HDR auto weight
            // rAutoBrightWeight
            //
            // Variable name: rAutoBrightWeight.i4X1
            // Max bright enhance probability threshold to get min auto bright weight (i4Y1)
            // Unit: weighting average pixel count
            // Default value: 4000
            // Data range: Integer, i4X1 > 0
            // Constraints: N/A.
            // Effect: The larger i4X1, larger bright enhance probability zone will get min auto bright weight (i4Y1)
            //
            // Variable name: rAutoBrightWeight.i4Y1
            // Min auto bright weight according to i4X1
            // Unit: 1024*%/100
            // Default value: 256
            // Data range: Integer, 0 ~ 1024
            // Constraints: N/A.
            // Effect: We will at least get i4Y1 weight
            //
            // Variable name: rAutoBrightWeight.i4X2
            // Min bright enhance probability threshold to get max auto bright weight i4Y2
            // Unit: weighting average pixel count
            // Default value: 5000
            // Data range: Integer, i4X2 > 0
            // Constraints: N/A.
            // Effect: The larger i4X2, smaller bright enhance probability zone will get max auto bright weight (i4Y2)
            //
            // Variable name: rAutoBrightWeight.i4Y2
            // Max auto bright weight according to i4X2
            // Unit: 1024*%/100
            // Default value: 768
            // Data range: Integer, 0 ~ 1024
            // Constraints: N/A.
            // Effect: The bright enhance probability larger than i4X2 will get max auto bright weight of i4Y2
            /**************************************************/
            {                   
                // rAutoBrightWeight
                INT32 u4X1;
                INT32 u4Y1;
                INT32 u4X2;
                INT32 u4Y2;
            },

            /**************************************************/
            // Feature name: rAutoABLWeight
            // HDR auto ABL weight interpolation table
            // Influence: auto ABL weight, auto night weight, HDR auto weight
            // rAutoABLWeight
            //
            // Variable name: rAutoABLWeight.i4X1
            // Max ABL probability threshold to get min auto ABL weight (i4Y1)
            // Unit: 1024*%/100
            // Default value: 0
            // Data range: Integer, 0 ~ 1024
            // Constraints: N/A.
            // Effect: The larger i4X1, larger ABL probability zone will get min auto ABL weight (i4Y1)
            //
            // Variable name: rAutoABLWeight.i4Y1
            // Min auto ABL weight according to i4X1
            // Unit: 1024*%/100
            // Default value: 1024
            // Data range: Integer, 0 ~ 1024
            // Constraints: N/A.
            // Effect: We will at least get i4Y1 weight
            //
            // Variable name: rAutoABLWeight.i4X2
            // Min ABL probability threshold to get max auto ABL weight i4Y2
            // Unit: 1024*%/100
            // Default value: 512
            // Data range: Integer, 0 ~ 1024
            // Constraints: N/A.
            // Effect: The larger i4X2, smaller ABL probability zone will get max auto ABL weight (i4Y2)
            //
            // Variable name: rAutoABLWeight.i4Y2
            // Max auto ABL weight according to i4X2
            // Unit: 1024*%/100
            // Default value: 1024
            // Data range: Integer, 0 ~ 1024
            // Constraints: N/A.
            // Effect: The ABL probability larger than i4X2 will get max auto ABL weight of i4Y2
            /**************************************************/
            {   
                // rAutoABLWeight
                INT32 u4X1;
                INT32 u4Y1;
                INT32 u4X2;
                INT32 u4Y2;
            },

            /**************************************************/
            // Feature name: rAutoLVWeightL
            // HDR auto LV weight interpolation table
            // It is for low LV specially, LV higher than 40 will get weight 1024
            // Influence: auto LV weight, auto night weight, HDR auto weight
            // rAutoLVWeightL
            //
            // Variable name: rAutoLVWeightL.i4X1
            // Max LV threshold to get min auto LV weight (i4Y1)
            // Unit: LV*10
            // Default value: 30
            // Data range: Integer, 0 ~ 180
            // Constraints: N/A.
            // Effect: The larger i4X1, larger LV zone will get min auto LV weight (i4Y1)
            //
            // Variable name: rAutoLVWeightL.i4Y1
            // Min auto LV weight according to i4X1
            // Unit: 1024*%/100
            // Default value: 768
            // Data range: Integer, 0 ~ 1024
            // Constraints: N/A.
            // Effect: We will at least get i4Y1 weight
            //
            // Variable name: rAutoLVWeightL.i4X2
            // Min LV threshold to get max auto LV weight i4Y2
            // Unit: LV*10
            // Default value: 40
            // Data range: Integer, 0 ~ 180
            // Constraints: N/A.
            // Effect: The larger i4X2, smaller LV zone will get max auto LV weight (i4Y2)
            //
            // Variable name: rAutoLVWeightL.i4Y2
            // Max auto LV weight according to i4X2
            // Unit: 1024*%/100
            // Default value: 1024
            // Data range: Integer, 0 ~ 1024
            // Constraints: N/A.
            // Effect: The LV larger than i4X2 will get max auto LV weight of i4Y2
            /**************************************************/
            {    
                // rAutoLVWeightL
                INT32 u4X1;
                INT32 u4Y1;
                INT32 u4X2;
                INT32 u4Y2;
            },

            /**************************************************/
            // Feature name: rAutoLVWeightH
            // HDR auto LV weight lower bound, determined by high LV
            // If scene LV is high, it raise HDR AE weight
            // Influence: auto LV weight, auto night weight, HDR auto weight
            // rAutoLVWeightH
            //
            // Variable name: rAutoLVWeightH.i4X1
            // Max LV threshold to get min auto LV weight lower bound (i4Y1)
            // Unit: LV*10
            // Default value: 100
            // Data range: Integer, 0 ~ 180
            // Constraints: N/A.
            // Effect: The larger i4X1, larger LV zone will get min auto LV weight lower bound (i4Y1)
            //
            // Variable name: rAutoLVWeightH.i4Y1
            // Min auto LV weight lower bound according to i4X1
            // Unit: 1024*%/100
            // Default value: 256
            // Data range: Integer, 0 ~ 1024
            // Constraints: N/A.
            // Effect: We will at least get i4Y1 weight for auto LV lower bound
            //
            // Variable name: rAutoLVWeightH.i4X2
            // Min LV threshold to get max auto LV weight lower bound i4Y2
            // Unit: LV*10
            // Default value: 130
            // Data range: Integer, 0 ~ 180
            // Constraints: N/A.
            // Effect: The larger i4X2, smaller LV zone will get max auto LV weight lower bound (i4Y2)
            //
            // Variable name: rAutoLVWeightH.i4Y2
            // Max auto LV weight lower bound according to i4X2
            // Unit: 1024*%/100
            // Default value: 512
            // Data range: Integer, 0 ~ 1024
            // Constraints: N/A.
            // Effect: The LV larger than i4X2 will get max auto LV weight lower bound (i4Y2)
            /**************************************************/
            {                   
                // rAutoLVWeightH
                INT32 u4X1;
                INT32 u4Y1;
                INT32 u4X2;
                INT32 u4Y2;
            },

            /**************************************************/
            // Feature name: rAutoNightWeight
            // HDR auto weight interpolation table, determined by night scene probability
            // Influence: HDR auto weight
            // rAutoNightWeight
            //
            // Variable name: rAutoNightWeight.i4X1
            // Max night scene probability threshold to get max HDR auto weight (i4Y1)
            // Unit: LV*10
            // Default value: 1024
            // Data range: Integer, 0 ~ 180
            // Constraints: N/A.
            // Effect: The larger i4X1, larger night scene probability zone will get max HDR auto weight (i4Y1)
            //
            // Variable name: rAutoNightWeight.i4Y1
            // Max HDR auto weight according to i4X1
            // Unit: 1024*%/100
            // Default value: 512
            // Data range: Integer, 0 ~ 1024
            // Constraints: N/A.
            // Effect: The higher i4Y1, the higher HDR auto weight we will get
            //
            // Variable name: rAutoNightWeight.i4X2
            // Min night scene probability threshold to get min HDR auto weight i4Y2
            // Unit: LV*10
            // Default value: 2048
            // Data range: Integer, 0 ~ 180
            // Constraints: N/A.
            // Effect: The larger i4X2, smaller night scene probability zone will get min HDR auto weight (i4Y2)
            //
            // Variable name: rAutoNightWeight.i4Y2
            // Min HDR auto weight according to i4X2
            // Unit: 1024*%/100
            // Default value: 256
            // Data range: Integer, 0 ~ 1024
            // Constraints: N/A.
            // Effect: The higher i4Y2, the higher HDR auto weight we will get
            /**************************************************/
            {                   
                // rAutoNightWeight
                INT32 u4X1;
                INT32 u4Y1;
                INT32 u4X2;
                INT32 u4Y2;
            },

            /**************************************************/
            // Feature name: rHdrAoeTarget
            // AOE information for HDR AE calculation
            // HDR scene share the same property as over exposure
            //
            // Variable name: i4AoePercent
            // The percent for AOE to calculate current AOE Y from bright
            // Unit: 10*%
            // Default value: 25
            // Data range: Integer, 0 ~ 1000
            // Constraints: N/A.
            // Effect: The larger i4AoePercent, more percent of histogram from the bright side will be accumulated for AOE current Y
            //
            // Variable name: i4AoeLV
            // The LV thresholds to deliver different AOE target
            // Unit: LV*10
            // Default value: {50, 100, 150}
            // Data range: Integer, 0 ~ 180
            // Constraints: N/A.
            // Effect: Differentiate the AOE target by LV
            //
            // Variable name: i4AoeTarget
            // Different AOE targets differentiated by LV
            // Unit: Y value in 8 bits
            // Default value: {200, 200, 200}
            // Data range: Integer, 0 ~ 255
            // Constraints: N/A.
            // Effect: Different LV delivers different AOE target
            /**************************************************/
            {
                //rHdrAoeTarget
                MINT32  i4AoePercent;
                MINT32  i4AoeLV[3];
                MINT32  i4AoeTarget[3];
            },

            /**************************************************/
            // Feature name: rHdrNightTarget
            // Night scene information for HDR AE calculation
            // HDR scene has almost the same property as night scene,
            // but if we use higher HDR ratio in night scene,
            // the noise will be large because of the high ISO in night scene.
            // So, night scene should use lower HDR ratio
            // rHdrNightTarget
            /**************************************************/
            {
                /**************************************************/
                // Variable name: i4NightPercent
                // The percent for night scene to calculate current night scene Y from bright
                // Default value: 150
                // Data range: Integer, 0 ~ 1000
                // Constraints: N/A.
                // Effect: The larger i4NightPercent, more percent of histogram from the bright side will be accumulated for night scene current Y
                /**************************************************/
                MINT32  i4NightPercent;

                /**************************************************/
                // Feature name: rNightTarget
                // Night scene target interpolation table, determined by night scene probability
                // Influence: HDR night scene target Y, HDR night scene target gain, HDR target gain, HDR target Y
                // rNightTarget
                //
                // Variable name: rNightTarget.i4X1
                // Max night scene probability threshold to get max night scene target (i4Y1)
                // Unit: 1024*%/100
                // Default value: 0
                // Data range: Integer, 0 ~ 1024
                // Constraints: N/A.
                // Effect: The larger i4X1, larger night scene probability zone will get max night scene target (i4Y1)
                //
                // Variable name: rNightTarget.i4Y1
                // Max night scene target according to i4X1
                // Unit: Y value in 8 bits
                // Default value: 80
                // Data range: Integer, 0 ~ 255
                // Constraints: N/A.
                // Effect: The higher i4Y1, the higher night scene target we will get
                //
                // Variable name: rNightTarget.i4X2
                // Min night scene probability threshold to get min night scene target i4Y2
                // Unit: 1024*%/100
                // Default value: 1024
                // Data range: Integer, 0 ~ 1024
                // Constraints: N/A.
                // Effect: The larger i4X2, smaller night scene probability zone will get min night scene target (i4Y2)
                //
                // Variable name: rNightTarget.i4Y2
                // Min night scene target according to i4X2
                // Unit: Y value in 8 bits
                // Default value: 60
                // Data range: Integer, 0 ~ 255
                // Constraints: N/A.
                // Effect: The higher i4Y2, the higher night scene target we will get
                /**************************************************/
                {               
                    // rNightTarget
                    INT32 u4X1;
                    INT32 u4Y1;
                    INT32 u4X2;
                    INT32 u4Y2;
                }
            },

            /**************************************************/
            // Feature name: rTargetLimitL
            // HDR AE target clamping for low LV
            // The LV lower than the low LV threshold use this table,
            // between low LV threshold and medium LV threshold use the interpolation result of medium/low LV
            // Influence: HDR AE target Y min/max clamping range for low LV scene
            // rTargetLimitL
            /**************************************************/
            {
                /**************************************************/
                // Variable name: rTargetLimitL.i4LVLimit
                // Low LV threshold for determining HDR AE target max/min clamping interpolation table
                // Unit: LV*10
                // Default value: 60
                // Data range: Integer, 0 ~ 180
                // Constraints: N/A.
                // Effect: The LV value lower than rTargetLimitL.i4LVLimit should use rTargetMinLimit interpolation table
                /**************************************************/
                MINT32  i4LVLimit; //rTargetLimitL.i4LVLimit

                /**************************************************/
                // Feature name: rTargetLimitL.rTargetMinLimit
                // For low LV, HDR AE target min threshold interpolation table
                // Influence: HDR AE target Y min clamping range for low LV scene
                // rTargetLimitL.rTargetMinLimit
                //
                // Variable name: rTargetLimitL.rTargetMinLimit.i4X1
                // For low LV, HDR contrast EVD interpolation lower bound for HDR AE target min threshold
                // Unit: EV*1000
                // Default value: 4000
                // Data range: Integer, i4X1 > 0
                // Constraints: N/A.
                // Effect: The larger i4X1, larger HDR contrast EVD zone will get HDR AE target of i4X1
                //
                // Variable name: rTargetLimitL.rTargetMinLimit.i4Y1
                // HDR target min threshold according to i4X1
                // Unit: Y value in 8 bits
                // Default value: 10
                // Data range: Integer, 0 ~ 255
                // Constraints: N/A.
                // Effect: The higher i4Y1, the higher HDR target min threshold we will get
                //
                // Variable name: rTargetLimitL.rTargetMinLimit.i4X2
                // For low LV, HDR contrast EVD interpolation upper bound for HDR AE target min threshold
                // Unit: EV*1000
                // Default value: 6000
                // Data range: Integer, i4X2 > 0
                // Constraints: N/A.
                // Effect: The larger i4X2, smaller HDR contrast EVD zone will get HDR target threshold of i4Y2
                //
                // Variable name: rTargetLimitL.rTargetMinLimit.i4Y2
                // HDR target min threshold according to i4X2
                // Unit: Y value in 8 bits
                // Default value: 10
                // Data range: Integer, 0 ~ 255
                // Constraints: N/A.
                // Effect: The higher i4Y2, the higher HDR target min threshold we will get
                /**************************************************/
                {               
                    // rTargetLimitL.rTargetMinLimit
                    INT32 u4X1;     // rTargetLimitL.rTargetMinLimit.i4X1
                    INT32 u4Y1;     // rTargetLimitL.rTargetMinLimit.i4Y1
                    INT32 u4X2;     // rTargetLimitL.rTargetMinLimit.i4X2
                    INT32 u4Y2;     // rTargetLimitL.rTargetMinLimit.i4Y2
                },

                /**************************************************/
                // Feature name: rTargetLimitL.rTargetMaxLimit
                // For low LV, max HDR AE target threshold interpolation table
                // Influence: HDR AE target Y max clamping range for low LV scene
                // rTargetLimitL.rTargetMaxLimit
                //
                // Variable name: rTargetLimitL.rTargetMaxLimit.i4X1
                // For low LV, HDR contrast EVD interpolation lower bound for HDR AE target max threshold
                // Unit: EV*1000
                // Default value: 4000
                // Data range: Integer, i4X1 > 0
                // Constraints: N/A.
                // Effect: The larger i4X1, larger HDR contrast EVD zone will get HDR AE target of i4X1
                //
                // Variable name: rTargetLimitL.rTargetMaxLimit.i4Y1
                // HDR target max threshold according to i4X1
                // Unit: Y value in 8 bits
                // Default value: 50
                // Data range: Integer, 0 ~ 255
                // Constraints: N/A.
                // Effect: The higher i4Y1, the higher HDR target max threshold we will get
                //
                // Variable name: rTargetLimitL.rTargetMaxLimit.i4X2
                // For low LV, HDR contrast EVD interpolation upper bound for HDR AE target max threshold
                // Unit: EV*1000
                // Default value: 6000
                // Data range: Integer, i4X2 > 0
                // Constraints: N/A.
                // Effect: The larger i4X2, smaller HDR contrast EVD zone will get HDR AE target max threshold of i4Y2
                //
                // Variable name: rTargetLimitL.rTargetMaxLimit.i4Y2
                // HDR target max threshold according to i4X2
                // Unit: Y value in 8 bits
                // Default value: 50
                // Data range: Integer, 0 ~ 255
                // Constraints: N/A.
                // Effect: The higher i4Y2, the higher HDR target max threshold we will get
                /**************************************************/
                {   
                    // rTargetLimitL.rTargetMaxLimit
                    INT32 u4X1;     // rTargetLimitL.rTargetMaxLimit.i4X1
                    INT32 u4Y1;     // rTargetLimitL.rTargetMaxLimit.i4Y1
                    INT32 u4X2;     // rTargetLimitL.rTargetMaxLimit.i4X2
                    INT32 u4Y2;     // rTargetLimitL.rTargetMaxLimit.i4Y2
                }
            },

            /**************************************************/
            // Feature name: rTargetLimitM
            // HDR AE target clamping for medium LV
            // The LV between low LV threshold and medium LV threshold use the interpolation result of low/medium LV
            // The LV between medium LV threshold and high LV threshold use the interpolation result of medium/high LV
            // Influence: HDR AE target Y min/max clamping range for medium LV scene
            // rTargetLimitM
            /**************************************************/
            {
                /**************************************************/
                // Variable name: rTargetLimitM.i4LVLimit
                // Medium LV threshold for determining HDR AE target max/min clamping interpolation table
                // Unit: LV*10
                // Default value: 80
                // Data range: Integer, 0 ~ 180
                // Constraints: N/A.
                // Effect: The rTargetLimitL.i4LVLimit < LV < rTargetLimitM.i4LVLimit should use rTargetLimitM interpolation table
                /**************************************************/
                MINT32  i4LVLimit;             // rTargetLimitM.i4LVLimit

                /**************************************************/
                // Feature name: rTargetLimitM.rTargetMinLimit
                // For medium LV, HDR AE target min threshold interpolation table
                // Influence: HDR AE target Y min clamping range for medium LV scene
                // rTargetLimitM.rTargetMinLimit
                //
                // Variable name: rTargetLimitM.rTargetMinLimit.i4X1
                // For medium LV, HDR contrast EVD interpolation lower bound for HDR AE target min threshold
                // Unit: EV*1000
                // Default value: 4000
                // Data range: Integer, i4X1 > 0
                // Constraints: N/A.
                // Effect: The larger i4X1, larger HDR contrast EVD zone will get HDR AE target min threshold of i4X1
                //
                // Variable name: rTargetLimitM.rTargetMinLimit.i4Y1
                // HDR target min threshold according to i4X1
                // Unit: Y value in 8 bits
                // Default value: none
                // Data range: Integer, 0 ~ 255
                // Constraints: N/A.
                // Effect: The higher i4Y1, the higher HDR target min threshold we will get
                //
                // Variable name: rTargetLimitM.rTargetMinLimit.i4X2
                // For medium LV, HDR contrast EVD interpolation upper bound for HDR AE target min threshold
                // Unit: EV*1000
                // Default value: 6000
                // Data range: Integer, i4X2 > 0
                // Constraints: N/A.
                // Effect: The larger i4X2, smaller HDR contrast EVD zone will get higher HDR AE target min threshold of i4Y2
                //
                // Variable name: rTargetLimitM.rTargetMinLimit.i4Y2
                // HDR target min threshold according to i4X2
                // Unit: Y value in 8 bits
                // Default value: none
                // Data range: Integer, 0 ~ 255
                // Constraints: N/A.
                // Effect: The higher i4Y2, the higher HDR target min threshold we will get
                /**************************************************/
                {               
                    // rTargetLimitM.rTargetMinLimit
                    INT32 u4X1;       // rTargetLimitM.rTargetMinLimit.i4X1
                    INT32 u4Y1;       // rTargetLimitM.rTargetMinLimit.i4Y1
                    INT32 u4X2;       // rTargetLimitM.rTargetMinLimit.i4X2
                    INT32 u4Y2;       // rTargetLimitM.rTargetMinLimit.i4Y2
                },

                /**************************************************/
                // Feature name: rTargetLimitM.rTargetMaxLimit
                // For medium LV, max HDR AE target threshold interpolation table
                // Influence: HDR AE target Y max clamping range for medium LV scene
                // rTargetLimitM.rTargetMaxLimit
                //
                // Variable name: rTargetLimitM.rTargetMaxLimit.i4X1
                // For medium LV, HDR contrast EVD interpolation lower bound for max HDR AE target threshold
                // Unit: EV*1000
                // Default value: 4000
                // Data range: Integer, i4X1 > 0
                // Constraints: N/A.
                // Effect: The larger i4X1, larger HDR contrast EVD zone will get HDR AE target max threshold of i4X1
                //
                // Variable name: rTargetLimitM.rTargetMaxLimit.i4Y1
                // HDR target max threshold according to i4X1
                // Unit: Y value in 8 bits
                // Default value: 50
                // Data range: Integer, 0 ~ 255
                // Constraints: N/A.
                // Effect: The higher i4Y1, the higher HDR target max threshold we will get
                //
                // Variable name: rTargetLimitM.rTargetMaxLimit.i4X2
                // For medium LV, HDR contrast EVD interpolation upper bound for HDR AE target max threshold
                // Unit: EV*1000
                // Default value: 6000
                // Data range: Integer, i4X2 > 0
                // Constraints: N/A.
                // Effect: The larger i4X2, smaller HDR contrast EVD zone will get higher HDR AE target max threshold of i4Y2
                //
                // Variable name: rTargetLimitM.rTargetMaxLimit.i4Y2
                // HDR target max threshold according to i4X2
                // Unit: Y value in 8 bits
                // Default value: 50
                // Data range: Integer, 0 ~ 255
                // Constraints: N/A.
                // Effect: The higher i4Y2, the higher HDR target max threshold we will get
                /**************************************************/
                {               
                    // rTargetLimitM.rTargetMaxLimit
                    INT32 u4X1;       // rTargetLimitM.rTargetMaxLimit.i4X1
                    INT32 u4Y1;       // rTargetLimitM.rTargetMaxLimit.i4Y1
                    INT32 u4X2;       // rTargetLimitM.rTargetMaxLimit.i4X2
                    INT32 u4Y2;       // rTargetLimitM.rTargetMaxLimit.i4Y2
                }
            },

            /**************************************************/
            // Feature name: rTargetLimitH
            // HDR AE target clamping for high LV
            // The LV higher than the high LV threshold use this table,
            // between medium LV threshold and high LV threshold use the interpolation result of medium/high LV
            // Influence: HDR AE target Y min/max clamping range for low LV scene
            // rTargetLimitH
            /**************************************************/
            {
                /**************************************************/
                // Variable name: rTargetLimitH.i4LVLimit
                // High LV threshold for determining HDR AE target max/min clamping interpolation table
                // Unit: LV*10
                // Default value: 80
                // Data range: Integer, 0 ~ 180
                // Constraints: N/A.
                // Effect: The LV larger than rTargetLimitH.i4LVLimit should use rTargetLimitH interpolation table
                /**************************************************/
                MINT32  i4LVLimit;        // rTargetLimitH.i4LVLimit

                /**************************************************/
                // Feature name: rTargetLimitH.rTargetMinLimit
                // For high LV, HDR AE target min threshold interpolation table
                // Influence: HDR AE target Y min clamping range for high LV scene
                // rTargetLimitH.rTargetMinLimit
                //
                // Variable name: rTargetLimitH.rTargetMinLimit.i4X1
                // For high LV, HDR contrast EVD interpolation lower bound for HDR AE target min threshold
                // Unit: EV*1000
                // Default value: 4000
                // Data range: Integer, i4X1 > 0
                // Constraints: N/A.
                // Effect: The larger i4X1, larger HDR contrast EVD zone will get HDR AE target min threshold of i4X1
                //
                // Variable name: rTargetLimitH.rTargetMinLimit.i4Y1
                // HDR target min threshold according to i4X1
                // Unit: Y value in 8 bits
                // Default value: 25
                // Data range: Integer, 0 ~ 255
                // Constraints: N/A.
                // Effect: The higher i4Y1, the higher HDR target min threshold we will get
                //
                // Variable name: rTargetLimitH.rTargetMinLimit.i4X2
                // For high LV, HDR contrast EVD interpolation upper bound for HDR AE target min threshold
                // Unit: EV*1000
                // Default value: 6000
                // Data range: Integer, i4X2 > 0
                // Constraints: N/A.
                // Effect: The larger i4X2, smaller HDR contrast EVD zone will get higher HDR AE target min threshold of i4Y2
                //
                // Variable name: rTargetLimitH.rTargetMinLimit.i4Y2
                // HDR target min threshold according to i4X2
                // Unit: Y value in 8 bits
                // Default value: 40
                // Data range: Integer, 0 ~ 255
                // Constraints: N/A.
                // Effect: The higher i4Y2, the higher HDR target min threshold we will get
                /**************************************************/
                {               
                    // rTargetLimitH.rTargetMinLimit
                    INT32 u4X1;       // rTargetLimitH.rTargetMinLimit.i4X1
                    INT32 u4Y1;       // rTargetLimitH.rTargetMinLimit.i4Y1
                    INT32 u4X2;       // rTargetLimitH.rTargetMinLimit.i4X2
                    INT32 u4Y2;       // rTargetLimitH.rTargetMinLimit.i4Y2
                },

                /**************************************************/
                // Feature name: rTargetLimitH.rTargetMaxLimit
                // For high LV, HDR AE target max threshold interpolation table
                // Influence: HDR AE target Y max clamping range for high LV scene
                // rTargetLimitH.rTargetMaxLimit
                //
                // Variable name: rTargetLimitH.rTargetMaxLimit.i4X1
                // For high LV, HDR contrast EVD interpolation lower bound for max HDR AE target threshold
                // Unit: EV*1000
                // Default value: 4000
                // Data range: Integer, i4X1 > 0
                // Constraints: N/A.
                // Effect: The larger i4X1, larger HDR contrast EVD zone will get HDR AE target max threshold of i4X1
                //
                // Variable name: rTargetLimitH.rTargetMaxLimit.i4Y1
                // HDR target max threshold according to i4X1
                // Unit: Y value in 8 bits
                // Default value: 50
                // Data range: Integer, 0 ~ 255
                // Constraints: N/A.
                // Effect: The higher i4Y1, the higher HDR target max threshold we will get
                //
                // Variable name: rTargetLimitH.rTargetMaxLimit.i4X2
                // For high LV, HDR contrast EVD interpolation upper bound for HDR AE target max threshold
                // Unit: EV*1000
                // Default value: 6000
                // Data range: Integer, i4X2 > 0
                // Constraints: N/A.
                // Effect: The larger i4X2, smaller HDR contrast EVD zone will get higher HDR AE target max threshold of i4Y2
                //
                // Variable name: rTargetLimitH.rTargetMaxLimit.i4Y2
                // HDR target max threshold according to i4X2
                // Unit: Y value in 8 bits
                // Default value: 50
                // Data range: Integer, 0 ~ 255
                // Constraints: N/A.
                // Effect: The higher i4Y2, the higher HDR target max threshold we will get
                /**************************************************/
                {               
                    // rTargetLimitH.rTargetMaxLimit
                    INT32 u4X1;       // rTargetLimitH.rTargetMaxLimit.i4X1
                    INT32 u4Y1;       // rTargetLimitH.rTargetMaxLimit.i4Y1
                    INT32 u4X2;       // rTargetLimitH.rTargetMaxLimit.i4X2
                    INT32 u4Y2;       // rTargetLimitH.rTargetMaxLimit.i4Y2
                }
            }
        },
        {                       // rHdrMiscProp
            {                   // rFaceAEProp
                /**************************************************/
                // Feature name: rFaceHdrProb
                // Face HDR probability interpolation table
                // rFaceHdrProb
                //
                // Variable name: rFaceHdrProb.i4X1
                // Max face bright tone probability to get max night scene target (i4Y1)
                // Unit: weighting average pixel count
                // Default value: 2200
                // Data range: Integer, 0 ~ 1024
                // Constraints: N/A.
                // Effect: The larger i4X1, larger face bright tone probability zone will get max face HDR target (i4Y1)
                //
                // Variable name: rFaceHdrProb.i4Y1
                // Max face HDR target according to i4X1
                // Unit: 1024*%/100
                // Default value: 512
                // Data range: Integer, 0 ~ 1024
                // Constraints: N/A.
                // Effect: The higher i4Y1, the higher face HDR target we will get
                //
                // Variable name: rFaceHdrProb.i4X2
                // Min face bright tone probability threshold to get min face HDR target i4Y2
                // Unit: weighting average pixel count
                // Default value: 3200
                // Data range: Integer, i4X1 > 0
                // Constraints: N/A.
                // Effect: The larger i4X2, smaller face bright tone probability zone will get min face HDR target (i4Y2)
                //
                // Variable name: rFaceHdrProb.i4Y2
                // Min face HDR target according to i4X2
                // Unit: 1024*%/100
                // Default value: 256
                // Data range: Integer, 0 ~ 1024
                // Constraints: N/A.
                // Effect: The higher i4Y2, the higher face HDR target we will get
                /**************************************************/
                {               
                    // rFaceHdrProb
                    INT32 u4X1;
                    INT32 u4Y1;
                    INT32 u4X2;
                    INT32 u4Y2;
                }
            },
            {                   
                // rTouchAEProp
                // TBD
            }
        },

        /**************************************************/
        // Feature name: rHdrcHdr
        // Calculate cHDR detection information
        // rHdrcHdr
        /**************************************************/
        {
            /**************************************************/
            // Variable name: i4LEThr
            // Current Y accumulated histogram from dark for LE information
            // Unit: Y value in 8 bits
            // Default value: 40
            // Data range: Integer, 0 ~ 255
            // Constraints: N/A.
            // Effect: The higher i4LEThr, more bins of histogram will be accumulated from dark side
            //
            // Variable name: i4SERatio
            // Current Y accumulated histogram percentage from bright for SE information
            // Unit:10*%
            // Default value: 20
            // Data range: Integer, 0 ~ 255
            // Constraints: N/A.
            // Effect: The higher i4SERatio, more % of histogram will be accumulated from bright side
            //
            // Variable name: i4SETarget
            // SE default target Y
            // Unit: Y value in 8 bits
            // Default value: 180
            // Data range: Integer, 0 ~ 255
            // Constraints: N/A.
            // Effect: The higher i4SETarget, the higher SE target Y
            //
            // Variable name: i4BaseGain
            // The base gain for AE target
            // Unit: 1024*gain
            // Default value: 1024
            // Data range: Integer, i4BaseGain > 0
            // Constraints: N/A.
            // Effect: The higher i4BaseGain, the higher base for gain
            /**************************************************/
            MINT32                  i4LEThr;
            MINT32                  i4SERatio;
            MINT32                  i4SETarget;
            MINT32                  i4BaseGain;
        }
    };